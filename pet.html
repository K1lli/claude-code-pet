<!DOCTYPE html>
<html>
<head>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body {
    background: transparent;
    overflow: hidden;
    width: 260px;
    height: 300px;
    user-select: none;
    -webkit-app-region: no-drag;
  }

  .scene {
    width: 260px;
    height: 300px;
    position: relative;
    overflow: visible;
  }

  /* ---- SPEECH BUBBLE ---- */
  .speech-bubble {
    position: absolute;
    top: 6px;
    left: 12px;
    right: 12px;
    background: linear-gradient(135deg, #fdf2f8, #f0e6ff);
    color: #4a3660;
    font-family: 'Segoe UI', sans-serif;
    font-size: 12px;
    line-height: 1.35;
    padding: 8px 12px;
    border-radius: 16px;
    border: 1.5px solid rgba(219, 170, 220, 0.4);
    box-shadow: 0 2px 16px rgba(180, 120, 200, 0.25), 0 0 8px rgba(245, 160, 192, 0.15);
    z-index: 60;
    opacity: 0;
    transform: scale(0.7) translateY(8px);
    transition: opacity 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
    pointer-events: none;
    max-height: 90px;
    overflow: hidden;
    text-align: center;
  }
  .speech-bubble.visible {
    opacity: 1;
    transform: scale(1) translateY(0);
  }
  .speech-bubble::after {
    content: '';
    position: absolute;
    bottom: -7px;
    left: 50%;
    transform: translateX(-50%) rotate(45deg);
    width: 10px;
    height: 10px;
    background: linear-gradient(135deg, transparent 50%, #f0e6ff 50%);
    border-right: 1.5px solid rgba(219, 170, 220, 0.4);
    border-bottom: 1.5px solid rgba(219, 170, 220, 0.4);
  }
  .speech-bubble .bubble-source {
    display: none;
  }
  .speech-bubble .bubble-text {
    word-break: break-word;
    display: -webkit-box;
    -webkit-line-clamp: 3;
    -webkit-box-orient: vertical;
    overflow: hidden;
    font-weight: 700;
  }
  /* WhatsApp notification layout inside speech bubble */
  .wa-notif { text-align: left; }
  .wa-notif-header {
    display: flex;
    align-items: center;
    gap: 5px;
    margin-bottom: 3px;
  }
  .wa-logo { width: 16px; height: 16px; flex-shrink: 0; }
  .wa-sender { font-weight: 700; font-size: 12px; color: #25d366; }
  .wa-msg {
    font-size: 11.5px;
    font-weight: 600;
    color: #4a3660;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 180px;
  }
  .wa-time { font-size: 9px; font-weight: 400; color: #9b7eb0; margin-top: 2px; }

  .status-label {
    display: none;
  }

  /* ---- CREATURE ---- */
  .creature {
    position: absolute;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 120px;
    height: 120px;
    transition: filter 0.3s;
    -webkit-app-region: no-drag;
  }


  /* ---- HOVER STATS TOOLTIP ---- */
  .stats-tooltip {
    position: absolute;
    bottom: 0; left: 0;
    width: 260px;
    height: 220px;
    background: rgba(0,0,0,0.82);
    border-radius: 10px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 3px;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s;
    z-index: 50;
    padding: 12px 16px;
  }
  /* Stats tooltip hidden â€” view stats via Tray â†’ Stats */
  .stats-tooltip .stats-title {
    font-family: 'Segoe UI', sans-serif;
    font-size: 11px;
    font-weight: bold;
    color: #ffd700;
    letter-spacing: 0.5px;
    margin-bottom: 4px;
  }
  .stats-tooltip .stat-row {
    display: flex;
    align-items: center;
    width: 100%;
    gap: 6px;
    font-family: 'Segoe UI', sans-serif;
    font-size: 9px;
    color: rgba(255,255,255,0.85);
  }
  .stat-row .stat-name {
    width: 62px;
    text-align: right;
    text-transform: uppercase;
    letter-spacing: 0.3px;
  }
  .stat-row .stat-bar-bg {
    flex: 1;
    height: 4px;
    background: rgba(255,255,255,0.15);
    border-radius: 2px;
    overflow: hidden;
  }
  .stat-row .stat-bar-fill {
    height: 100%;
    border-radius: 2px;
    transition: width 0.3s;
  }
  .stat-row .stat-lv {
    width: 22px;
    font-weight: bold;
    font-size: 9px;
  }

  /* ---- SKILL LABEL + XP BAR + LEVEL BADGE ---- */
  .skill-label {
    display: none;
  }
  .xp-row {
    display: none;
  }
  .level-badge {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: rgba(0,0,0,0.5);
    color: #fff;
    font-family: 'Segoe UI', sans-serif;
    font-size: 8px;
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    transition: background 0.4s;
  }
  .xp-bar {
    width: 80px;
    height: 3px;
    background: rgba(0,0,0,0.3);
    border-radius: 1.5px;
    overflow: hidden;
    flex-shrink: 0;
  }
  .xp-fill {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, #0984e3, #00cec9);
    border-radius: 1.5px;
    transition: width 0.5s ease;
  }
  .xp-fill.flash {
    background: linear-gradient(90deg, #ffeaa7, #fdcb6e, #ffeaa7);
  }


  /* ---- MILESTONE LAYER ---- */
  .milestone-layer {
    position: absolute;
    top: 0; left: 0;
    width: 120px; height: 120px;
    pointer-events: none;
    z-index: 3;
  }
  .milestone-layer svg {
    position: absolute;
    transition: opacity 0.5s;
  }

  /* ---- LEVEL UP CELEBRATION ---- */
  .glow-pulse {
    animation: glow-pulse-anim 0.6s ease-in-out 3 !important;
  }
  @keyframes glow-pulse-anim {
    0%, 100% { filter: brightness(1) drop-shadow(0 0 0 transparent); }
    50% { filter: brightness(1.4) drop-shadow(0 0 12px rgba(255,215,0,0.8)); }
  }

  /* ---- CONFETTI ---- */
  .confetti-layer {
    position: absolute;
    top: 0; left: 0;
    width: 260px; height: 300px;
    pointer-events: none;
    z-index: 30;
    overflow: hidden;
  }
  .confetti {
    position: absolute;
    width: 6px;
    height: 6px;
    opacity: 0;
  }
  @keyframes confetti-fall {
    0% { opacity: 1; transform: translateY(-20px) translateX(0) rotate(0deg) scale(1); }
    25% { opacity: 1; transform: translateY(40px) translateX(var(--drift, 10px)) rotate(180deg) scale(0.95); }
    50% { opacity: 0.9; transform: translateY(100px) translateX(calc(var(--drift, 10px) * -0.5)) rotate(400deg) scale(0.8); }
    100% { opacity: 0; transform: translateY(230px) translateX(var(--drift, 10px)) rotate(720deg) scale(0.4); }
  }

  /* ---- LAYERS ---- */
  .accessory-layer {
    position: absolute;
    top: 0; left: 0;
    width: 120px; height: 120px;
    pointer-events: none;
    z-index: 5;
  }
  .accessory-layer svg {
    position: absolute;
    opacity: 0;
    transition: opacity 0.3s;
  }
  .accessory-layer svg.active { opacity: 1; }

  .particle-layer {
    position: absolute;
    top: -20px; left: -20px;
    width: 160px; height: 160px;
    pointer-events: none;
    z-index: 4;
  }
  .particle-layer .p {
    position: absolute;
    opacity: 0;
    pointer-events: none;
    line-height: 1;
  }

  /* â”€â”€ PARTICLE KEYFRAMES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  @keyframes float-up {
    0% { opacity: 0; transform: translateY(60px) scale(0.5); }
    15% { opacity: 0.9; transform: translateY(40px) scale(1); }
    100% { opacity: 0; transform: translateY(-30px) scale(0.6); }
  }
  @keyframes rain-down {
    0% { opacity: 0; transform: translateY(-30px); }
    20% { opacity: 0.9; }
    100% { opacity: 0; transform: translateY(80px); }
  }
  @keyframes wiggle-float {
    0% { opacity: 0; transform: translateY(50px) rotate(0deg); }
    20% { opacity: 0.9; }
    100% { opacity: 0; transform: translateY(-20px) rotate(20deg); }
  }
  @keyframes orbit {
    0% { opacity: 0.8; transform: rotate(0deg) translateX(45px) rotate(0deg); }
    100% { opacity: 0.3; transform: rotate(360deg) translateX(45px) rotate(-360deg); }
  }
  @keyframes pop-up {
    0% { opacity: 0; transform: translateY(10px) scale(0); }
    30% { opacity: 1; transform: translateY(-5px) scale(1.2); }
    60% { opacity: 1; transform: translateY(-10px) scale(1); }
    100% { opacity: 0; transform: translateY(-25px) scale(0.8); }
  }
  @keyframes crack-shake {
    0%, 100% { transform: translateX(0); }
    20% { transform: translateX(-2px) rotate(-1deg); }
    40% { transform: translateX(2px) rotate(1deg); }
    60% { transform: translateX(-1px); }
    80% { transform: translateX(1px); }
  }
  @keyframes sway-float {
    0% { opacity: 0; transform: translateY(50px) translateX(0); }
    15% { opacity: 0.8; }
    50% { transform: translateY(10px) translateX(8px); }
    100% { opacity: 0; transform: translateY(-25px) translateX(-5px); }
  }

  /* ================================================================
     ANU SPRITE SYSTEM
     ================================================================ */

  .scene.skin-sprite .creature {
    overflow: visible;
    z-index: 20;
    width: 190px;
    height: 190px;
    bottom: 5px;
  }

  .scene.skin-sprite .sprite-skin {
    display: block !important;
    width: 190px;
    height: 190px;
    top: 0;
    left: 0;
    object-fit: contain;
  }

  /* ---- Sprite state animations: override ALL with gentle breathe ---- */
  /* Anu (girlfriend sprite) gets no movement animations â€” only subtle scale breathing */
  .scene.skin-sprite .sprite-skin {
    animation: sprite-gentle-breathe 4s ease-in-out infinite !important;
  }
  @keyframes sprite-gentle-breathe {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.008); }
  }
  /* Error shake: keep but limit to 3 reps and tiny amplitude */
  .scene.skin-sprite.state-error .sprite-skin {
    animation: sprite-error-shake 0.3s ease-in-out 3 !important;
  }
  @keyframes sprite-error-shake {
    0%, 100% { transform: scale(1); }
    25% { transform: scale(1) translateX(-1px); }
    75% { transform: scale(1) translateX(1px); }
  }


  /* ---- Sprite tier color filters ---- */
  /* Tiers 0-4: no filter â€” sprite looks best with original colors */
  /* Tier 5 (Legendary): prismatic rainbow cycle */
  .skin-sprite.tier-5 .sprite-skin {
    animation: prismatic-sprite 4s ease-in-out infinite;
  }

  @keyframes prismatic-sprite {
    0%, 100% { filter: hue-rotate(0deg) saturate(1.2) brightness(1.05); }
    25% { filter: hue-rotate(90deg) saturate(1.3) brightness(1.1); }
    50% { filter: hue-rotate(180deg) saturate(1.2) brightness(1.05); }
    75% { filter: hue-rotate(270deg) saturate(1.3) brightness(1.1); }
  }

  /* ================================================================
     CLICK INTERACTION SYSTEM
     ================================================================ */

  .click-heart {
    position: absolute;
    pointer-events: none;
    font-size: 18px;
    opacity: 0;
    z-index: 100;
    animation: heart-float 1.5s ease-out forwards;
  }
  .click-heart.big { font-size: 26px; }

  @keyframes heart-float {
    0% { opacity: 0; transform: translateY(0) scale(0.3) rotate(0deg); }
    15% { opacity: 1; transform: translateY(-10px) scale(1.1) rotate(-10deg); }
    50% { opacity: 0.8; transform: translateY(-40px) scale(1) rotate(10deg); }
    100% { opacity: 0; transform: translateY(-80px) scale(0.5) rotate(-5deg); }
  }

  .petting-blush {
    position: absolute;
    top: 30px; left: 25px;
    width: 70px; height: 30px;
    background: radial-gradient(ellipse, rgba(255,100,130,0.4) 0%, transparent 70%);
    border-radius: 50%;
    opacity: 0;
    z-index: 15;
    pointer-events: none;
    transition: opacity 0.3s;
  }
  .petting-blush.visible { opacity: 1; }

  /* click-bounce disabled â€” no jumping */

  .creature {
    -webkit-app-region: no-drag;
    cursor: pointer;
  }

  /* â”€â”€ PHOTO FRAME â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .photo-frame {
    position: absolute;
    bottom: 60px;
    right: -5px;
    width: 55px;
    height: 55px;
    z-index: 40;
    pointer-events: auto;
    cursor: pointer;
    -webkit-app-region: no-drag;
  }
  .photo-frame img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 50%;
    border: 2px solid #f5a0c0;
    box-shadow: 0 2px 8px rgba(245, 160, 192, 0.4);
    transition: transform 0.3s, box-shadow 0.3s;
  }
  .photo-frame img:hover {
    transform: scale(1.1);
    box-shadow: 0 4px 16px rgba(245, 160, 192, 0.6);
  }
  .photo-frame::before {
    content: 'ðŸ’•';
    position: absolute;
    top: -8px;
    right: -4px;
    font-size: 12px;
    z-index: 41;
  }

  /* â”€â”€ NEW PARTICLE TYPES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

  .kiss-particle {
    position: absolute;
    pointer-events: none;
    font-size: 22px;
    opacity: 0;
    z-index: 100;
    animation: kiss-bounce 1.8s ease-out forwards;
  }
  @keyframes kiss-bounce {
    0% { opacity: 0; transform: translateY(0) scale(0.3) rotate(0deg); }
    15% { opacity: 1; transform: translateY(-15px) scale(1.2) rotate(-15deg); }
    40% { opacity: 0.9; transform: translateY(-35px) scale(1) rotate(15deg); }
    70% { opacity: 0.5; transform: translateY(-55px) scale(0.8) rotate(-10deg); }
    100% { opacity: 0; transform: translateY(-80px) scale(0.4) rotate(360deg); }
  }

  .sparkle-burst-particle {
    position: absolute;
    pointer-events: none;
    font-size: 16px;
    opacity: 0;
    z-index: 100;
    animation: sparkle-burst 1.2s ease-out forwards;
  }
  @keyframes sparkle-burst {
    0% { opacity: 0; transform: translate(0, 0) scale(0); }
    20% { opacity: 1; transform: scale(1.3); }
    100% { opacity: 0; transform: scale(0.3); }
  }

  .confetti-particle {
    position: absolute;
    pointer-events: none;
    width: 6px;
    height: 10px;
    opacity: 0;
    z-index: 100;
    animation: confetti-fall 2.5s ease-in forwards;
  }
  @keyframes confetti-fall {
    0% { opacity: 0; transform: translateY(-20px) rotate(0deg); }
    10% { opacity: 1; }
    100% { opacity: 0; transform: translateY(120px) rotate(720deg); }
  }

  .music-note-particle {
    position: absolute;
    pointer-events: none;
    font-size: 18px;
    opacity: 0;
    z-index: 100;
    animation: music-float 2s ease-out forwards;
  }
  @keyframes music-float {
    0% { opacity: 0; transform: translateY(0) translateX(0) scale(0.5); }
    20% { opacity: 1; transform: translateY(-10px) translateX(5px) scale(1); }
    50% { opacity: 0.8; transform: translateY(-30px) translateX(-8px); }
    100% { opacity: 0; transform: translateY(-60px) translateX(10px) scale(0.6); }
  }

  .snowflake-particle {
    position: absolute;
    pointer-events: none;
    font-size: 14px;
    opacity: 0;
    z-index: 100;
    animation: snowflake-drift 3s ease-in forwards;
  }
  @keyframes snowflake-drift {
    0% { opacity: 0; transform: translateY(-30px) translateX(0) rotate(0deg); }
    15% { opacity: 0.9; }
    50% { transform: translateY(40px) translateX(10px) rotate(180deg); }
    100% { opacity: 0; transform: translateY(100px) translateX(-5px) rotate(360deg); }
  }

  .raindrop-particle {
    position: absolute;
    pointer-events: none;
    font-size: 12px;
    opacity: 0;
    z-index: 100;
    animation: raindrop-fall 1.5s linear forwards;
  }
  @keyframes raindrop-fall {
    0% { opacity: 0; transform: translateY(-30px); }
    10% { opacity: 0.8; }
    100% { opacity: 0; transform: translateY(110px); }
  }

  .sunray-particle {
    position: absolute;
    pointer-events: none;
    font-size: 20px;
    opacity: 0;
    z-index: 100;
    animation: sunray-spin 3s ease-in-out forwards;
  }
  @keyframes sunray-spin {
    0% { opacity: 0; transform: rotate(0deg) scale(0.5); }
    20% { opacity: 0.9; transform: rotate(45deg) scale(1); }
    80% { opacity: 0.6; transform: rotate(270deg) scale(0.8); }
    100% { opacity: 0; transform: rotate(360deg) scale(0.3); }
  }

  .letter-particle {
    position: absolute;
    pointer-events: none;
    font-size: 20px;
    opacity: 0;
    z-index: 100;
    animation: letter-float 2.5s ease-out forwards;
  }
  @keyframes letter-float {
    0% { opacity: 0; transform: translateY(20px) scale(0.3) rotate(-10deg); }
    20% { opacity: 1; transform: translateY(0) scale(1.1) rotate(5deg); }
    50% { opacity: 0.8; transform: translateY(-20px) scale(1) rotate(-5deg); }
    100% { opacity: 0; transform: translateY(-50px) scale(0.5) rotate(10deg); }
  }

  .zzz-particle {
    position: absolute;
    pointer-events: none;
    font-size: 16px;
    font-weight: bold;
    color: #a29bfe;
    opacity: 0;
    z-index: 100;
    animation: zzz-drift 2.5s ease-out forwards;
  }
  @keyframes zzz-drift {
    0% { opacity: 0; transform: translateY(0) translateX(0) scale(0.5); }
    20% { opacity: 0.8; transform: translateY(-10px) translateX(5px) scale(1); }
    60% { opacity: 0.5; transform: translateY(-30px) translateX(12px) scale(1.2); }
    100% { opacity: 0; transform: translateY(-50px) translateX(18px) scale(1.5); }
  }

  .sweat-particle {
    position: absolute;
    pointer-events: none;
    font-size: 14px;
    opacity: 0;
    z-index: 100;
    animation: sweat-drip 1.2s ease-in forwards;
  }
  @keyframes sweat-drip {
    0% { opacity: 0; transform: translateY(0) scale(0.5); }
    20% { opacity: 0.9; transform: translateY(2px) scale(1); }
    100% { opacity: 0; transform: translateY(30px) scale(0.6); }
  }

  /* Wiggle animation for tickle */
  .creature.wiggle-anim {
    animation: tickle-wiggle 0.4s ease-in-out;
  }
  @keyframes tickle-wiggle {
    0%, 100% { transform: rotate(0deg); }
    20% { transform: rotate(-5deg); }
    40% { transform: rotate(5deg); }
    60% { transform: rotate(-3deg); }
    80% { transform: rotate(3deg); }
  }

  /* ---- RADIAL CONTEXT MENU ---- */
  .radial-menu {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 200;
    overflow: visible;
  }
  .radial-menu.visible {
    pointer-events: none; /* buttons handle their own clicks */
  }

  /* Soft glow ring backdrop */
  .radial-ring {
    position: absolute;
    border-radius: 50%;
    background: radial-gradient(circle, rgba(180, 80, 220, 0.12) 0%, rgba(120, 40, 180, 0.06) 50%, transparent 75%);
    border: 1px solid rgba(220, 160, 255, 0.12);
    transform: translate(-50%, -50%);
    opacity: 0;
    transition: opacity 0.25s ease;
    pointer-events: none;
  }
  .radial-menu.visible .radial-ring {
    opacity: 1;
  }

  /* Each action button */
  .rm-btn {
    position: absolute;
    width: 46px; height: 46px;
    border-radius: 50%;
    background: linear-gradient(145deg, rgba(45, 20, 70, 0.92), rgba(65, 30, 90, 0.88));
    backdrop-filter: blur(10px);
    border: 1.5px solid rgba(210, 150, 255, 0.45);
    box-shadow: 0 4px 18px rgba(150, 60, 220, 0.4), inset 0 1px 0 rgba(255, 200, 255, 0.12);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    cursor: pointer;
    transform: translate(-50%, -50%) scale(0);
    transition: transform 0.28s cubic-bezier(0.34, 1.56, 0.64, 1),
                box-shadow 0.18s ease,
                background 0.18s ease,
                border-color 0.18s ease;
    pointer-events: none;
    -webkit-app-region: no-drag;
    user-select: none;
    line-height: 1;
  }
  .radial-menu.visible .rm-btn {
    transform: translate(-50%, -50%) scale(1);
    pointer-events: auto;
  }
  .rm-btn:hover {
    background: linear-gradient(145deg, rgba(180, 70, 240, 0.88), rgba(120, 40, 200, 0.92));
    border-color: rgba(240, 180, 255, 0.7);
    box-shadow: 0 6px 24px rgba(200, 80, 255, 0.6), 0 0 0 3px rgba(220, 140, 255, 0.2);
    transform: translate(-50%, -50%) scale(1.2) !important;
  }
  .rm-btn:active {
    transform: translate(-50%, -50%) scale(0.95) !important;
  }

  /* Central action label badge â€” positioned at top, never over character */
  .rm-center-badge {
    position: absolute;
    left: 50%;
    top: auto;
    bottom: 4px;
    transform: translateX(-50%);
    background: linear-gradient(135deg, rgba(40, 15, 60, 0.92), rgba(70, 25, 90, 0.88));
    border: 1px solid rgba(200, 140, 255, 0.35);
    border-radius: 12px;
    padding: 3px 10px;
    font-family: 'Segoe UI', sans-serif;
    font-size: 10px;
    font-weight: 600;
    color: rgba(240, 200, 255, 0.92);
    letter-spacing: 0.4px;
    white-space: nowrap;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.15s ease;
    box-shadow: 0 2px 10px rgba(150, 50, 200, 0.3);
    z-index: 201;
  }
  .rm-center-badge.visible {
    opacity: 1;
  }


</style>
</head>
<body>
  <div class="scene" id="scene">
    <div class="speech-bubble" id="speechBubble">
      <div class="bubble-source" id="bubbleSource"></div>
      <div class="bubble-text" id="bubbleText"></div>
    </div>
    <div class="status-label" id="statusLabel">idle</div>
    <div class="creature" id="creature">
      <img class="sprite-skin" id="spriteSkin" src="" alt=""
           style="display:none; position:absolute; z-index:10;" />
      <div class="petting-blush" id="pettingBlush"></div>
      <div class="milestone-layer" id="milestoneLayer"></div>
      <div class="accessory-layer" id="accessoryLayer"></div>
      <div class="particle-layer" id="particleLayer"></div>
    </div>
    <div class="skill-label" id="skillLabel">CHILLING LV.1</div>
    <div class="xp-row">
      <div class="level-badge" id="levelBadge">1</div>
      <div class="xp-bar"><div class="xp-fill" id="xpFill"></div></div>
    </div>
    <div class="confetti-layer" id="confettiLayer"></div>
    <div class="stats-tooltip" id="statsTooltip"></div>
    <!-- Radial context menu (right-click) -->
    <div class="radial-menu" id="radialMenu">
      <div class="radial-ring" id="radialRing"></div>
      <div class="rm-center-badge" id="rmCenterBadge"></div>
    </div>
    <div class="photo-frame" id="photoFrame" style="display:none">
      <img id="photoFrameImg" src="" alt="" />
    </div>
  </div>

  <script>
    const { ipcRenderer, shell } = require("electron");

    // â”€â”€ DEBUG LOGGER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Writes timestamped events to debug.log in project root via main process.
    // Usage: dbg("event-name", { key: value, ... })
    function dbg(event, data) {
      try {
        ipcRenderer.send("debug-log", {
          ts: new Date().toISOString(),
          event,
          data: data || {}
        });
      } catch (_) {}
    }
    // Log any uncaught JS errors
    window.addEventListener("error", (e) => {
      dbg("js-error", { msg: e.message, src: e.filename, line: e.lineno });
    });
    dbg("renderer-start", { ua: navigator.userAgent.slice(0, 60) });
    const scene = document.getElementById("scene");
    const label = document.getElementById("statusLabel");
    const accessoryLayer = document.getElementById("accessoryLayer");
    const particleLayer = document.getElementById("particleLayer");
    const milestoneLayer = document.getElementById("milestoneLayer");
    const xpFill = document.getElementById("xpFill");
    const levelBadge = document.getElementById("levelBadge");
    const creature = document.getElementById("creature");
    let currentState = "idle";
    let particleInterval = null;
    const skillLabel = document.getElementById("skillLabel");
    let currentTier = 0;
    let unlockedMilestones = new Set();
    let lastProgression = null;
    let currentSkin = "girlfriend";
    let vibeActive = false;   // must be declared early â€” used in buildSceneClassName

    // Base path for assets â€” set by main process, defaults to relative
    let assetsBasePath = "assets";

    // â”€â”€ SOUND SYSTEM (howler.js) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let petSounds = null;
    let soundEnabled = true;
    let soundVolume = 0.7;

    function initSounds() {
      try {
        const { Howl } = require("howler");
        const base = assetsBasePath + "/sounds/";
        petSounds = new Howl({
          src: [base + "pet-sounds.webm", base + "pet-sounds.mp3"],
          sprite: {
            giggle:       [0, 1000],
            kiss:         [1000, 500],
            purr:         [1500, 2000],
            yay:          [3500, 1000],
            gasp:         [4500, 500],
            hmm:          [5000, 1000],
            "sleepy-sigh":[6000, 1500],
            typing:       [7500, 2000],
            "error-buzz": [9500, 500],
            tada:         [10000, 1500],
            "message-pop":[11500, 300],
            "music-chime":[11800, 500],
            "good-morning":[12300, 1000],
            "good-night": [13300, 1000],
          },
          volume: soundVolume,
        });
        console.log("[Sound] Initialized howler.js sound system");
      } catch (e) {
        console.log("[Sound] howler.js not available or sound files missing:", e.message);
        petSounds = null;
      }
    }

    function playSound(name) {
      if (!soundEnabled || !petSounds) return;
      try {
        petSounds.volume(soundVolume);
        petSounds.play(name);
      } catch (e) {
        // Sound file might not exist yet
      }
    }

    function getSpriteUrl(expression) {
      return assetsBasePath + "/skins/girlfriend/" + expression + ".png";
    }

    function updateSpriteSkin(expressionName) {
      const spriteEl = document.getElementById("spriteSkin");
      // focused.png looks angry/stern â€” swap to thinking for coding states
      if (expressionName === "focused") expressionName = "thinking";
      let src = getSpriteUrl(expressionName) || getSpriteUrl("neutral");
      // Electron needs file:// protocol for absolute paths
      if (src && !src.startsWith("file:") && require("path").isAbsolute(src)) {
        src = "file:///" + src;
      }
      if (!src) {
        dbg("sprite-error", { reason: "empty-src", expressionName });
        spriteEl.style.display = "none";
        return;
      }
      dbg("sprite-load", { expressionName, src });
      spriteEl.onerror = () => {
        dbg("sprite-img-error", { src: spriteEl.src, expressionName });
        spriteEl.style.display = "none";
      };
      spriteEl.onload = () => {
        dbg("sprite-img-ok", { src: spriteEl.src, expressionName });
        spriteEl.onerror = null;
      };
      spriteEl.src = src;
      spriteEl.style.display = "block";
    }

    // Expression abstraction layer: 43+ states â†’ 20 expression categories
    const EXPRESSION_MAP = {
      // happy â€” idle default! She should always look happy to see you ðŸ’•
      idle: "happy", "idle-vibing": "vibe", "idle-coffee": "vibe",
      // happy/thinking â€” stargazing, downloading, reading, cooking (calm activities)
      "idle-stargazing": "happy", downloading: "thinking",
      reading: "happy", "reading-scholar": "thinking", cooking: "happy",
      // happy â€” success, vibing, flow, growing, dancing, rainbow, treasure (was: excited)
      success: "happy", "coding-flow": "happy", "thinking-growing": "happy",
      "idle-dancing": "vibe", "idle-rainbow": "vibe", "searching-treasure": "happy",
      // focused â€” coding, testing, testing-scientist
      coding: "focused", testing: "focused", "testing-scientist": "focused",
      // thinking â€” thinking variants
      thinking: "thinking", "thinking-cooking": "thinking", "thinking-creating": "thinking", "thinking-processing": "thinking",
      // focused â€” hacking, detective, action (determined removed: looks too sad)
      "coding-hacking": "focused", "debugging-detective": "focused", "thinking-action": "focused",
      // surprised â€” eureka, deploy variants
      "thinking-eureka": "surprised", "deploying-warp": "surprised", "deploying-satellite": "surprised",
      deploying: "surprised",
      // angry â€” rage, deleting
      "debugging-rage": "angry", deleting: "angry",
      // worried â€” error
      error: "worried",
      // worried â€” debugging, hatching
      debugging: "worried", hatching: "worried",
      // scared â€” exploring unknown, thunderstorm (via weather)
      "thinking-exploring": "scared",
      // sad â€” (triggered by timer: long error sessions)
      // crying â€” (triggered by timer: consecutive errors)
      // sleepy â€” ONLY at night (22-5) via timer, and idle-sleepy
      "idle-sleepy": "sleepy",
      // reading-ancient and meditation look calm, not sad
      "reading-ancient": "thinking", "idle-meditation": "meditating",
      // smug â€” galaxy brain, magical thinking
      "thinking-galaxy": "smug", "thinking-magical": "smug",
      // silly â€” searching, juggling (was: excited); thinking-silly gets winking_blep
      searching: "silly", "thinking-silly": "winking_blep", "idle-juggling": "silly",
      // embarrassed â€” (triggered: double-click, petting at loveâ‰¥25)
      // shy â€” (triggered: first greeting, petting at love<25)
      // thinking â€” installing; happy â€” butterfly idle
      installing: "thinking", "idle-butterfly": "happy",
      // proud â€” stretching, perfectionist, level-up, deep search
      "idle-stretching": "proud", "testing-perfectionist": "proud", "searching-deep": "proud",
    };

    function getExpressionClass(state) {
      const expr = EXPRESSION_MAP[state] || "happy";
      return "expr-" + expr;
    }

    function getSkinClass() {
      return "skin-sprite";
    }

    function buildSceneClassName(stateStr) {
      let cn = "scene state-" + stateStr + " tier-" + currentTier;
      const skinCls = getSkinClass();
      if (skinCls) cn += " " + skinCls;
      cn += " " + getExpressionClass(stateStr);
      // Update sprite image when expression changes (skip if vibe is active)
      const expr = EXPRESSION_MAP[stateStr] || "happy";
      if (!vibeActive) updateSpriteSkin(expr);
      dbg("build-scene", { stateStr, expr, vibeActive });
      console.log("[Skin] buildClassName:", cn, "| state:", stateStr, "| expr:", expr);
      return cn;
    }

    // Map state â†’ display name for the skill label
    const STATE_SKILL_NAME = {
      idle: "Chilling", "idle-vibing": "Vibing", "idle-sleepy": "Sleepy",
      "idle-coffee": "Coffee", "idle-stargazing": "Stargazing",
      "idle-stretching": "Stretching", "idle-dancing": "Dancing",
      "idle-butterfly": "Wondering", "idle-juggling": "Juggling",
      "idle-rainbow": "Rainbow", "idle-meditation": "Meditating",
      thinking: "Thinking", coding: "Coding", searching: "Searching",
      reading: "Reading", debugging: "Debugging", installing: "Installing",
      testing: "Testing", deploying: "Deploying", cooking: "Cooking",
      hatching: "Hatching", deleting: "Cleaning", downloading: "Downloading",
      success: "Success", error: "Error",
      "coding-flow": "Flow", "coding-hacking": "Hacking",
      "thinking-eureka": "Eureka", "thinking-galaxy": "Galaxy Brain",
      "thinking-cooking": "Thinking", "thinking-action": "Thinking",
      "thinking-creating": "Thinking", "thinking-processing": "Thinking",
      "thinking-growing": "Thinking", "thinking-magical": "Thinking",
      "thinking-silly": "Thinking", "thinking-exploring": "Thinking",
      "debugging-detective": "Detective", "debugging-rage": "Rage",
      "searching-treasure": "Treasure Hunt", "searching-deep": "Deep Diving",
      "reading-scholar": "Scholar", "reading-ancient": "Arcana",
      "testing-scientist": "Science", "testing-perfectionist": "Perfectionism",
      "deploying-warp": "Warp", "deploying-satellite": "Astronaut",
    };
    // Map state â†’ which skill key to show level for (null = pet level)
    const STATE_SKILL_KEY = {
      idle: null, "idle-vibing": null, "idle-sleepy": null,
      "idle-coffee": null, "idle-stargazing": null,
      "idle-stretching": "stretching", "idle-dancing": "dancing",
      "idle-butterfly": "wondering", "idle-juggling": "juggling",
      "idle-rainbow": "rainbow", "idle-meditation": "meditating",
      thinking: "thinking", coding: "coding", searching: "searching",
      reading: "reading", debugging: "debugging", installing: "installing",
      testing: "testing", deploying: "deploying", cooking: null,
      hatching: null, deleting: null, downloading: null,
      success: null, error: null,
      "coding-flow": "flow", "coding-hacking": "hacking",
      "thinking-eureka": "eureka", "thinking-galaxy": "galaxy brain",
      "thinking-cooking": "thinking", "thinking-action": "thinking",
      "thinking-creating": "thinking", "thinking-processing": "thinking",
      "thinking-growing": "thinking", "thinking-magical": "thinking",
      "thinking-silly": "thinking", "thinking-exploring": "thinking",
      "debugging-detective": "detective", "debugging-rage": "rage",
      "searching-treasure": "treasure hunting", "searching-deep": "deep diving",
      "reading-scholar": "scholarship", "reading-ancient": "arcana",
      "testing-scientist": "science", "testing-perfectionist": "perfectionism",
      "deploying-warp": "warp", "deploying-satellite": "astronaut",
    };

    // â”€â”€ SVG PARTICLE SHAPES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Tiny reusable SVG templates. Use COLOR as a placeholder to tint.

    const SVG = {
      // 4-point sparkle star
      sparkle: (c) => `<svg width="10" height="10" viewBox="0 0 10 10"><path d="M5,0 L6,4 L10,5 L6,6 L5,10 L4,6 L0,5 L4,4Z" fill="${c}"/></svg>`,
      // 5-point star
      star: (c) => `<svg width="12" height="12" viewBox="0 0 12 12"><path d="M6,0L7.5,4.2L12,4.6L8.5,7.8L9.7,12L6,9.8L2.3,12L3.5,7.8L0,4.6L4.5,4.2Z" fill="${c}"/></svg>`,
      // small circle / dot
      dot: (c) => `<svg width="8" height="8"><circle cx="4" cy="4" r="3.5" fill="${c}"/></svg>`,
      // hollow circle
      ring: (c) => `<svg width="10" height="10"><circle cx="5" cy="5" r="4" fill="none" stroke="${c}" stroke-width="1.5"/></svg>`,
      // small triangle
      tri: (c) => `<svg width="10" height="10" viewBox="0 0 10 10"><polygon points="5,0 10,10 0,10" fill="${c}"/></svg>`,
      // X mark
      cross: (c) => `<svg width="8" height="8" viewBox="0 0 8 8"><line x1="1" y1="1" x2="7" y2="7" stroke="${c}" stroke-width="2" stroke-linecap="round"/><line x1="7" y1="1" x2="1" y2="7" stroke="${c}" stroke-width="2" stroke-linecap="round"/></svg>`,
      // checkmark
      check: (c) => `<svg width="10" height="10" viewBox="0 0 10 10"><path d="M1,5.5 L3.5,8 L9,2" fill="none" stroke="${c}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`,
      // tiny gear/cog
      gear: (c) => `<svg width="12" height="12" viewBox="0 0 12 12"><circle cx="6" cy="6" r="2.5" fill="none" stroke="${c}" stroke-width="1.5"/><line x1="6" y1="0" x2="6" y2="2.5" stroke="${c}" stroke-width="1.5"/><line x1="6" y1="9.5" x2="6" y2="12" stroke="${c}" stroke-width="1.5"/><line x1="0" y1="6" x2="2.5" y2="6" stroke="${c}" stroke-width="1.5"/><line x1="9.5" y1="6" x2="12" y2="6" stroke="${c}" stroke-width="1.5"/></svg>`,
      // small diamond
      diamond: (c) => `<svg width="8" height="10" viewBox="0 0 8 10"><polygon points="4,0 8,5 4,10 0,5" fill="${c}"/></svg>`,
      // tiny lightning bolt
      bolt: (c) => `<svg width="8" height="14" viewBox="0 0 8 14"><polygon points="5,0 1,7 4,7 3,14 7,6 4,6" fill="${c}"/></svg>`,
      // small cloud puff
      cloud: (c) => `<svg width="14" height="10" viewBox="0 0 14 10"><ellipse cx="7" cy="6" rx="6" ry="4" fill="${c}" opacity="0.7"/><ellipse cx="4" cy="5" rx="4" ry="3.5" fill="${c}" opacity="0.6"/><ellipse cx="10" cy="5" rx="4" ry="3" fill="${c}" opacity="0.6"/></svg>`,
      // tiny page/file
      page: (c) => `<svg width="9" height="11" viewBox="0 0 9 11"><rect x="0" y="0" width="9" height="11" rx="1" fill="${c}"/><line x1="2" y1="3" x2="7" y2="3" stroke="#fff" stroke-width="0.8"/><line x1="2" y1="5.5" x2="6" y2="5.5" stroke="#fff" stroke-width="0.8"/><line x1="2" y1="8" x2="5" y2="8" stroke="#fff" stroke-width="0.8"/></svg>`,
      // down arrow
      arrowDown: (c) => `<svg width="8" height="10" viewBox="0 0 8 10"><line x1="4" y1="0" x2="4" y2="8" stroke="${c}" stroke-width="2"/><path d="M1,5 L4,9 L7,5" fill="none" stroke="${c}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`,
      // small bug with body + legs
      bug: (c) => `<svg width="12" height="12" viewBox="0 0 12 12"><ellipse cx="6" cy="7" rx="3.5" ry="4" fill="${c}"/><circle cx="6" cy="3" r="2" fill="${c}"/><line x1="2" y1="5" x2="0" y2="3" stroke="${c}" stroke-width="1"/><line x1="10" y1="5" x2="12" y2="3" stroke="${c}" stroke-width="1"/><line x1="2" y1="8" x2="0" y2="9" stroke="${c}" stroke-width="1"/><line x1="10" y1="8" x2="12" y2="9" stroke="${c}" stroke-width="1"/><circle cx="5" cy="2.5" r="0.7" fill="#fff"/><circle cx="7" cy="2.5" r="0.7" fill="#fff"/></svg>`,
      // dust puff
      dust: (c) => `<svg width="12" height="8" viewBox="0 0 12 8"><circle cx="3" cy="5" r="2.5" fill="${c}" opacity="0.5"/><circle cx="7" cy="4" r="3" fill="${c}" opacity="0.4"/><circle cx="10" cy="5" r="2" fill="${c}" opacity="0.3"/></svg>`,
    };

    // â”€â”€ ANIMATION CONFIG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // To add a new animation:
    //   1. Add a CSS .state-yourKeyword block above
    //   2. Add an entry here with label, accessory (SVG string), particles
    //   3. Update hook.js classifyTool() to emit that keyword
    //
    // Accessory: inline SVG string positioned relative to creature
    // Particles: { items: [svgStrings], anim: keyframeName, rate: ms }

    const ANIMATIONS = {
      idle: {
        label: "chilling...",
        accessory: null,
        particles: null,
      },

      "idle-vibing": {
        label: "vibing~",
        accessory: null,
        particles: {
          items: [
            `<span style="color:#74b9ff;font-size:14px;font-family:serif">&#9835;</span>`,
            `<span style="color:#a29bfe;font-size:12px;font-family:serif">&#9834;</span>`,
            `<span style="color:#fd79a8;font-size:13px;font-family:serif">&#9835;</span>`,
            SVG.sparkle("#74b9ff"),
          ],
          anim: "sway-float", rate: 800,
        },
      },

      "idle-sleepy": {
        label: "sleepy...",
        accessory: null,
        particles: {
          items: [
            `<span style="color:#a29bfe;font-size:14px;font-weight:bold;font-family:monospace;opacity:0.8">Z</span>`,
            `<span style="color:#6c5ce7;font-size:11px;font-weight:bold;font-family:monospace;opacity:0.6">z</span>`,
            `<span style="color:#a29bfe;font-size:9px;font-weight:bold;font-family:monospace;opacity:0.5">z</span>`,
          ],
          anim: "float-up", rate: 1200,
        },
      },

      "idle-coffee": {
        label: "coffee break",
        // Tiny coffee mug with steam
        accessory: `<svg viewBox="0 0 24 24" width="20" height="20" style="top:64px;left:74px;">
          <rect x="2" y="8" width="14" height="14" rx="2" fill="#b2bec3"/>
          <path d="M16,11 C20,11 20,19 16,19" fill="none" stroke="#b2bec3" stroke-width="2" stroke-linecap="round"/>
          <rect x="4" y="10" width="10" height="10" rx="1" fill="#795548" opacity="0.6"/>
          <path d="M6,6 Q7,2 8,6" fill="none" stroke="#dfe6e9" stroke-width="1.2" opacity="0.5">
            <animate attributeName="d" values="M6,6 Q7,2 8,6;M6,3 Q7,-1 8,3;M6,6 Q7,2 8,6" dur="2s" repeatCount="indefinite"/>
          </path>
          <path d="M10,5 Q11,1 12,5" fill="none" stroke="#dfe6e9" stroke-width="1.2" opacity="0.4">
            <animate attributeName="d" values="M10,5 Q11,1 12,5;M10,2 Q11,-2 12,2;M10,5 Q11,1 12,5" dur="2.5s" repeatCount="indefinite"/>
          </path>
        </svg>`,
        particles: {
          items: [SVG.cloud("#dfe6e9"), SVG.cloud("#b2bec3"), SVG.sparkle("#795548")],
          anim: "sway-float", rate: 1400,
        },
      },

      "idle-stargazing": {
        label: "stargazing...",
        accessory: null,
        particles: {
          items: [SVG.star("#74b9ff"), SVG.sparkle("#a29bfe"), SVG.star("#ffeaa7"), SVG.dot("#dfe6e9")],
          anim: "sway-float", rate: 1000,
        },
      },

      "idle-stretching": {
        label: "stretching~",
        accessory: null,
        particles: {
          items: [SVG.sparkle("#fdcb6e"), SVG.sparkle("#f0932b"), SVG.cloud("#ffeaa7")],
          anim: "sway-float", rate: 1200,
        },
      },

      "idle-dancing": {
        label: "dancing!",
        accessory: `<svg viewBox="0 0 24 24" width="20" height="20" style="top:-16px;left:48px;">
          <circle cx="12" cy="12" r="8" fill="#dfe6e9" stroke="#b2bec3" stroke-width="1"/>
          <line x1="12" y1="4" x2="12" y2="20" stroke="#b2bec3" stroke-width="0.5"/>
          <line x1="4" y1="12" x2="20" y2="12" stroke="#b2bec3" stroke-width="0.5"/>
          <line x1="6" y1="6" x2="18" y2="18" stroke="#b2bec3" stroke-width="0.5"/>
          <line x1="18" y1="6" x2="6" y2="18" stroke="#b2bec3" stroke-width="0.5"/>
          <circle cx="12" cy="12" r="8" fill="none" stroke="#fff" stroke-width="0.5" opacity="0.5">
            <animate attributeName="r" values="6;9;6" dur="1s" repeatCount="indefinite"/>
            <animate attributeName="opacity" values="0.5;0;0.5" dur="1s" repeatCount="indefinite"/>
          </circle>
        </svg>`,
        particles: {
          items: [
            `<span style="color:#ff6b6b;font-size:14px;font-family:serif">&#9835;</span>`,
            `<span style="color:#f9ca24;font-size:12px;font-family:serif">&#9834;</span>`,
            `<span style="color:#2ecc71;font-size:13px;font-family:serif">&#9835;</span>`,
            `<span style="color:#74b9ff;font-size:11px;font-family:serif">&#9834;</span>`,
            SVG.sparkle("#f9ca24"),
            SVG.sparkle("#ff6b6b"),
          ],
          anim: "sway-float", rate: 500,
        },
      },

      "idle-butterfly": {
        label: "butterfly!",
        accessory: `<svg viewBox="0 0 30 24" width="24" height="20" style="top:10px;left:80px;">
          <g>
            <animateTransform attributeName="transform" type="translate" values="0,0;-10,-8;-20,0;-10,8;0,0" dur="4s" repeatCount="indefinite"/>
            <ellipse cx="15" cy="12" rx="8" ry="6" fill="#fd79a8" opacity="0.7">
              <animate attributeName="ry" values="6;2;6" dur="0.5s" repeatCount="indefinite"/>
            </ellipse>
            <ellipse cx="15" cy="12" rx="5" ry="8" fill="#a29bfe" opacity="0.7">
              <animate attributeName="rx" values="5;1.5;5" dur="0.5s" repeatCount="indefinite"/>
            </ellipse>
            <ellipse cx="15" cy="12" rx="1" ry="4" fill="#2c1810"/>
            <circle cx="15" cy="7.5" r="1.5" fill="#2c1810"/>
          </g>
        </svg>`,
        particles: {
          items: [SVG.sparkle("#fd79a8"), SVG.dot("#a29bfe"), SVG.sparkle("#ffeaa7")],
          anim: "sway-float", rate: 1600,
        },
      },

      "idle-juggling": {
        label: "juggling!",
        accessory: `<svg viewBox="0 0 60 40" width="50" height="34" style="top:-20px;left:34px;">
          <circle cx="15" cy="20" r="5" fill="#ff6b6b">
            <animate attributeName="cx" values="15;30;45;30;15" dur="1.5s" repeatCount="indefinite"/>
            <animate attributeName="cy" values="20;5;20;5;20" dur="1.5s" repeatCount="indefinite"/>
          </circle>
          <circle cx="30" cy="5" r="5" fill="#f9ca24">
            <animate attributeName="cx" values="30;45;30;15;30" dur="1.5s" repeatCount="indefinite"/>
            <animate attributeName="cy" values="5;20;5;20;5" dur="1.5s" repeatCount="indefinite"/>
          </circle>
          <circle cx="45" cy="20" r="5" fill="#74b9ff">
            <animate attributeName="cx" values="45;30;15;30;45" dur="1.5s" repeatCount="indefinite"/>
            <animate attributeName="cy" values="20;5;20;5;20" dur="1.5s" repeatCount="indefinite"/>
          </circle>
        </svg>`,
        particles: null,
      },

      "idle-rainbow": {
        label: "rainbow!",
        accessory: `<svg viewBox="0 0 80 40" width="70" height="36" style="top:-24px;left:24px;">
          <path d="M5,38 Q40,-5 75,38" fill="none" stroke="#ff6b6b" stroke-width="3" opacity="0.7"/>
          <path d="M8,38 Q40,-2 72,38" fill="none" stroke="#f9ca24" stroke-width="3" opacity="0.7"/>
          <path d="M11,38 Q40,1 69,38" fill="none" stroke="#2ecc71" stroke-width="3" opacity="0.7"/>
          <path d="M14,38 Q40,4 66,38" fill="none" stroke="#74b9ff" stroke-width="3" opacity="0.7"/>
          <path d="M17,38 Q40,7 63,38" fill="none" stroke="#a29bfe" stroke-width="3" opacity="0.7"/>
          <animate attributeName="opacity" values="0.6;1;0.6" dur="2s" repeatCount="indefinite"/>
        </svg>`,
        particles: {
          items: [
            SVG.sparkle("#ff6b6b"), SVG.sparkle("#f9ca24"), SVG.sparkle("#2ecc71"),
            SVG.sparkle("#74b9ff"), SVG.sparkle("#a29bfe"), SVG.sparkle("#fd79a8"),
            SVG.star("#ff6b6b"), SVG.star("#f9ca24"), SVG.star("#2ecc71"),
          ],
          anim: "sway-float", rate: 300,
        },
      },

      "idle-meditation": {
        label: "meditating...",
        accessory: `<svg viewBox="0 0 60 60" width="50" height="50" style="top:5px;left:34px;">
          <g opacity="0.4">
            <animateTransform attributeName="transform" type="rotate" values="0 30 30;360 30 30" dur="12s" repeatCount="indefinite"/>
            <circle cx="30" cy="30" r="25" fill="none" stroke="#a29bfe" stroke-width="1" stroke-dasharray="4 4"/>
            <circle cx="30" cy="30" r="18" fill="none" stroke="#6c5ce7" stroke-width="1" stroke-dasharray="3 6"/>
            <circle cx="30" cy="30" r="11" fill="none" stroke="#a29bfe" stroke-width="1.5" stroke-dasharray="2 4"/>
            <path d="M30,5 L30,55 M5,30 L55,30 M12,12 L48,48 M48,12 L12,48" stroke="#d5ccff" stroke-width="0.5"/>
          </g>
        </svg>`,
        particles: {
          items: [SVG.dot("#a29bfe"), SVG.dot("#d5ccff"), SVG.sparkle("#6c5ce7")],
          anim: "orbit", rate: 1200,
        },
      },

      thinking: {
        label: "thinking...",
        // Thought bubble with animated dots
        accessory: `<svg viewBox="0 0 40 32" width="34" height="28" style="top:-14px;left:62px;">
          <ellipse cx="20" cy="12" rx="17" ry="12" fill="rgba(255,255,255,0.85)" stroke="#ddd" stroke-width="0.8"/>
          <circle cx="10" cy="26" r="3" fill="rgba(255,255,255,0.7)"/>
          <circle cx="6" cy="30" r="2" fill="rgba(255,255,255,0.5)"/>
          <circle cx="12" cy="12" r="2" fill="#f0932b" opacity="0.8">
            <animate attributeName="r" values="1.5;2.5;1.5" dur="1.2s" repeatCount="indefinite"/>
          </circle>
          <circle cx="20" cy="12" r="2" fill="#f0932b" opacity="0.8">
            <animate attributeName="r" values="1.5;2.5;1.5" dur="1.2s" begin="0.3s" repeatCount="indefinite"/>
          </circle>
          <circle cx="28" cy="12" r="2" fill="#f0932b" opacity="0.8">
            <animate attributeName="r" values="1.5;2.5;1.5" dur="1.2s" begin="0.6s" repeatCount="indefinite"/>
          </circle>
        </svg>`,
        particles: {
          items: [SVG.dot("#f0932b"), SVG.dot("#ffbe76"), SVG.ring("#f0932b"), SVG.sparkle("#ffbe76")],
          anim: "sway-float", rate: 1000,
        },
      },

      coding: {
        label: "coding!",
        particles: {
          items: [
            // Blue - keywords
            `<span style="color:#74b9ff;font-size:11px;font-weight:bold;font-family:monospace;text-shadow:0 0 4px rgba(116,185,255,0.5)">fn</span>`,
            `<span style="color:#74b9ff;font-size:11px;font-weight:bold;font-family:monospace;text-shadow:0 0 4px rgba(116,185,255,0.5)">if</span>`,
            `<span style="color:#74b9ff;font-size:11px;font-weight:bold;font-family:monospace;text-shadow:0 0 4px rgba(116,185,255,0.5)">let</span>`,
            // Green - strings
            `<span style="color:#2ecc71;font-size:10px;font-family:monospace;text-shadow:0 0 4px rgba(46,204,113,0.4)">"ok"</span>`,
            // Orange/yellow - operators & brackets
            `<span style="color:#f9ca24;font-size:11px;font-family:monospace;text-shadow:0 0 4px rgba(249,202,36,0.4)">=></span>`,
            `<span style="color:#f0932b;font-size:12px;font-family:monospace;text-shadow:0 0 4px rgba(240,147,43,0.4)">{}</span>`,
            `<span style="color:#fdcb6e;font-size:11px;font-family:monospace;text-shadow:0 0 4px rgba(253,203,110,0.4)">()</span>`,
            // Pink - numbers
            `<span style="color:#fd79a8;font-size:11px;font-family:monospace;text-shadow:0 0 4px rgba(253,121,168,0.4)">42</span>`,
            `<span style="color:#e84393;font-size:10px;font-family:monospace;text-shadow:0 0 4px rgba(232,67,147,0.4)">0x</span>`,
            // SVG sparkles in code-accent colors
            SVG.sparkle("#74b9ff"),
            SVG.sparkle("#2ecc71"),
            SVG.sparkle("#f9ca24"),
          ],
          anim: "float-up", rate: 500,
        },
      },

      success: {
        label: "done!",
        // Animated sparkle burst with spinning star and pulse ring
        accessory: `<svg viewBox="0 0 36 36" width="30" height="30" style="top:-12px;left:42px;">
          <path d="M18,2 L20,14 L32,16 L20,18 L18,30 L16,18 L4,16 L16,14Z" fill="#2ecc71" opacity="0.8">
            <animateTransform attributeName="transform" type="rotate" values="0 18 16;360 18 16" dur="4s" repeatCount="indefinite"/>
          </path>
          <circle cx="18" cy="16" r="4" fill="#27ae60">
            <animate attributeName="r" values="3;5;3" dur="0.8s" repeatCount="indefinite"/>
          </circle>
          <circle cx="18" cy="16" r="6" fill="none" stroke="#2ecc71" stroke-width="1" opacity="0.4">
            <animate attributeName="r" values="4;10;4" dur="1.2s" repeatCount="indefinite"/>
            <animate attributeName="opacity" values="0.5;0;0.5" dur="1.2s" repeatCount="indefinite"/>
          </circle>
        </svg>`,
        particles: {
          items: [SVG.star("#2ecc71"), SVG.sparkle("#27ae60"), SVG.check("#00b894"), SVG.star("#55efc4")],
          anim: "pop-up", rate: 400,
        },
      },

      error: {
        label: "uh oh...",
        // Flashing warning triangle
        accessory: `<svg viewBox="0 0 28 26" width="22" height="20" style="top:-4px;left:46px;">
          <polygon points="14,2 26,24 2,24" fill="#ffeaa7" stroke="#e17055" stroke-width="1.5" stroke-linejoin="round">
            <animate attributeName="fill" values="#ffeaa7;#fff3c4;#ffeaa7" dur="0.6s" repeatCount="indefinite"/>
          </polygon>
          <line x1="14" y1="10" x2="14" y2="17" stroke="#e17055" stroke-width="2.5" stroke-linecap="round"/>
          <circle cx="14" cy="21" r="1.5" fill="#e17055">
            <animate attributeName="r" values="1.5;2;1.5" dur="0.6s" repeatCount="indefinite"/>
          </circle>
        </svg>`,
        particles: {
          items: [SVG.cross("#e74c3c"), SVG.tri("#e17055"), SVG.sparkle("#ff7675"), SVG.bolt("#e74c3c")],
          anim: "crack-shake", rate: 600,
        },
      },

      // â”€â”€ RARE ACTIVITY VARIANTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      "coding-flow": {
        label: "in the zone! (coding)",
        particles: {
          items: [SVG.sparkle("#ffd700"), SVG.sparkle("#f9ca24"), SVG.star("#ffd700"), SVG.sparkle("#ffbe76")],
          anim: "float-up", rate: 500,
        },
      },

      "coding-hacking": {
        label: "hacking! (coding)",
        // Sunglasses SVG
        accessory: `<svg viewBox="0 0 44 16" width="40" height="14" style="top:34px;left:28px;">
          <rect x="2" y="4" width="14" height="10" rx="2" fill="rgba(0,0,0,0.85)" stroke="#2ecc71" stroke-width="0.5"/>
          <rect x="28" y="4" width="14" height="10" rx="2" fill="rgba(0,0,0,0.85)" stroke="#2ecc71" stroke-width="0.5"/>
          <line x1="16" y1="8" x2="28" y2="8" stroke="#2c1810" stroke-width="1.5"/>
          <line x1="2" y1="7" x2="-2" y2="5" stroke="#2c1810" stroke-width="1"/>
          <line x1="42" y1="7" x2="46" y2="5" stroke="#2c1810" stroke-width="1"/>
          <rect x="4" y="6" width="10" height="6" rx="1" fill="#2ecc71" opacity="0.15">
            <animate attributeName="opacity" values="0.1;0.25;0.1" dur="1s" repeatCount="indefinite"/>
          </rect>
          <rect x="30" y="6" width="10" height="6" rx="1" fill="#2ecc71" opacity="0.15">
            <animate attributeName="opacity" values="0.1;0.25;0.1" dur="1s" repeatCount="indefinite"/>
          </rect>
        </svg>`,
        particles: {
          items: [
            `<span style="color:#2ecc71;font-size:11px;font-weight:bold;font-family:monospace;text-shadow:0 0 6px rgba(46,204,113,0.7)">0</span>`,
            `<span style="color:#00ff41;font-size:10px;font-weight:bold;font-family:monospace;text-shadow:0 0 6px rgba(0,255,65,0.5)">1</span>`,
            `<span style="color:#2ecc71;font-size:9px;font-family:monospace;text-shadow:0 0 4px rgba(46,204,113,0.5)">0</span>`,
            `<span style="color:#00ff41;font-size:12px;font-weight:bold;font-family:monospace;text-shadow:0 0 6px rgba(0,255,65,0.7)">1</span>`,
            SVG.sparkle("#2ecc71"),
          ],
          anim: "rain-down", rate: 300,
        },
      },

      "thinking-eureka": {
        label: "eureka! (thinking)",
        // Glowing lightbulb
        accessory: `<svg viewBox="0 0 24 32" width="20" height="28" style="top:-18px;left:48px;">
          <ellipse cx="12" cy="12" rx="9" ry="10" fill="#ffd700" opacity="0.2">
            <animate attributeName="opacity" values="0.15;0.35;0.15" dur="1s" repeatCount="indefinite"/>
            <animate attributeName="rx" values="9;12;9" dur="1s" repeatCount="indefinite"/>
            <animate attributeName="ry" values="10;13;10" dur="1s" repeatCount="indefinite"/>
          </ellipse>
          <ellipse cx="12" cy="12" rx="7" ry="8" fill="#ffeaa7" stroke="#f9ca24" stroke-width="1"/>
          <rect x="9" y="20" width="6" height="4" rx="1" fill="#b2bec3"/>
          <line x1="9" y1="22" x2="15" y2="22" stroke="#636e72" stroke-width="0.5"/>
          <path d="M10,8 L10,14 M14,8 L14,14" stroke="#f0932b" stroke-width="1.2" stroke-linecap="round"/>
          <circle cx="12" cy="6" r="1.5" fill="#ffd700">
            <animate attributeName="r" values="1;2;1" dur="0.8s" repeatCount="indefinite"/>
          </circle>
        </svg>`,
        particles: {
          items: [SVG.sparkle("#ffd700"), SVG.star("#ffeaa7"), SVG.bolt("#f9ca24"), SVG.sparkle("#f0932b")],
          anim: "pop-up", rate: 600,
        },
      },

      "thinking-galaxy": {
        label: "galaxy brain! (thinking)",
        // Orbital rings
        accessory: `<svg viewBox="0 0 70 70" width="60" height="60" style="top:-5px;left:28px;">
          <g opacity="0.5">
            <animateTransform attributeName="transform" type="rotate" values="0 35 35;360 35 35" dur="8s" repeatCount="indefinite"/>
            <ellipse cx="35" cy="35" rx="30" ry="10" fill="none" stroke="#a29bfe" stroke-width="1" stroke-dasharray="4 3"/>
          </g>
          <g opacity="0.4">
            <animateTransform attributeName="transform" type="rotate" values="90 35 35;450 35 35" dur="10s" repeatCount="indefinite"/>
            <ellipse cx="35" cy="35" rx="25" ry="8" fill="none" stroke="#6c5ce7" stroke-width="1" stroke-dasharray="3 4"/>
          </g>
          <g opacity="0.3">
            <animateTransform attributeName="transform" type="rotate" values="45 35 35;405 35 35" dur="6s" repeatCount="indefinite"/>
            <ellipse cx="35" cy="35" rx="20" ry="6" fill="none" stroke="#d5ccff" stroke-width="1.5"/>
          </g>
        </svg>`,
        particles: {
          items: [SVG.star("#a29bfe"), SVG.sparkle("#6c5ce7"), SVG.dot("#d5ccff"), SVG.star("#ffeaa7")],
          anim: "orbit", rate: 600,
        },
      },

      // â”€â”€ THINKING THEMES (cosmetic variants) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      "thinking-cooking": {
        labels: ["baking...", "brewing...", "simmering...", "stewing...", "marinating...", "percolating..."],
        label: "simmering...",
        // Chef hat
        accessory: `<svg viewBox="0 0 36 28" width="32" height="24" style="top:0px;left:32px;">
          <ellipse cx="18" cy="22" rx="16" ry="4" fill="#f5f0e0"/>
          <rect x="6" y="6" width="24" height="16" rx="3" fill="#fff" stroke="#e0d8c0" stroke-width="0.8"/>
          <ellipse cx="18" cy="6" rx="10" ry="5" fill="#fff"/>
          <line x1="18" y1="2" x2="18" y2="5" stroke="#e0d8c0" stroke-width="0.8"/>
        </svg>`,
        particles: {
          items: [
            SVG.cloud("#dfe6e9"), SVG.cloud("#b2bec3"),
            SVG.sparkle("#f0932b"), SVG.sparkle("#ffeaa7"),
          ],
          anim: "float-up", rate: 800,
        },
      },

      "thinking-action": {
        labels: ["hustling...", "wrangling...", "mustering...", "working...", "accomplishing..."],
        label: "hustling...",
        // Flexed arm
        accessory: `<svg viewBox="0 0 28 28" width="24" height="24" style="top:28px;left:88px;">
          <path d="M4,24 L8,14 L14,10 L16,4 L20,6 L16,12 L18,14 L14,18 L10,24Z" fill="#e17055" stroke="#d63031" stroke-width="0.8"/>
          <ellipse cx="17" cy="5" rx="3" ry="2.5" fill="#e17055"/>
        </svg>`,
        particles: {
          items: [SVG.bolt("#ff7675"), SVG.sparkle("#fdcb6e"), SVG.bolt("#d63031"), SVG.sparkle("#ff7675")],
          anim: "pop-up", rate: 500,
        },
      },

      "thinking-creating": {
        labels: ["crafting...", "forging...", "tinkering...", "conjuring...", "concocting..."],
        label: "forging...",
        // Hammer & anvil
        accessory: `<svg viewBox="0 0 34 28" width="30" height="24" style="top:66px;left:72px;">
          <rect x="6" y="18" width="22" height="6" rx="1" fill="#636e72"/>
          <rect x="4" y="16" width="26" height="4" rx="1" fill="#95a5a6"/>
          <rect x="22" y="4" width="4" height="14" rx="1" fill="#b2bec3" transform="rotate(15,24,11)"/>
          <rect x="18" y="2" width="12" height="5" rx="2" fill="#dfe6e9" transform="rotate(15,24,4)"/>
          <circle cx="24" cy="14" r="1.5" fill="#fdcb6e">
            <animate attributeName="opacity" values="1;0.3;1" dur="0.6s" repeatCount="indefinite"/>
          </circle>
        </svg>`,
        particles: {
          items: [SVG.sparkle("#fdcb6e"), SVG.sparkle("#e17055"), SVG.bolt("#f0932b"), SVG.dot("#ff7675")],
          anim: "pop-up", rate: 400,
        },
      },

      "thinking-processing": {
        labels: ["computing...", "crunching...", "calculating...", "synthesizing...", "deciphering..."],
        label: "computing...",
        // Spinning gear
        accessory: `<svg viewBox="0 0 28 28" width="24" height="24" style="top:-12px;left:46px;">
          <g>
            <animateTransform attributeName="transform" type="rotate" values="0 14 14;360 14 14" dur="4s" repeatCount="indefinite"/>
            <circle cx="14" cy="14" r="6" fill="none" stroke="#00cec9" stroke-width="2.5"/>
            <circle cx="14" cy="14" r="3" fill="#0984e3"/>
            <rect x="12.5" y="1" width="3" height="5" rx="1" fill="#00cec9"/>
            <rect x="12.5" y="22" width="3" height="5" rx="1" fill="#00cec9"/>
            <rect x="1" y="12.5" width="5" height="3" rx="1" fill="#00cec9"/>
            <rect x="22" y="12.5" width="5" height="3" rx="1" fill="#00cec9"/>
          </g>
        </svg>`,
        particles: {
          items: [
            `<span style="color:#00cec9;font-size:11px;font-weight:bold;font-family:monospace;text-shadow:0 0 6px rgba(0,206,201,0.7)">0</span>`,
            `<span style="color:#0984e3;font-size:10px;font-weight:bold;font-family:monospace;text-shadow:0 0 6px rgba(9,132,227,0.5)">1</span>`,
            `<span style="color:#00cec9;font-size:9px;font-family:monospace;text-shadow:0 0 4px rgba(0,206,201,0.5)">0</span>`,
            `<span style="color:#0984e3;font-size:12px;font-weight:bold;font-family:monospace;text-shadow:0 0 6px rgba(9,132,227,0.7)">1</span>`,
            SVG.gear("#00cec9"),
          ],
          anim: "rain-down", rate: 350,
        },
      },

      "thinking-growing": {
        labels: ["germinating...", "incubating...", "hatching...", "unfurling...", "coalescing..."],
        label: "germinating...",
        // Sprout from head
        accessory: `<svg viewBox="0 0 24 28" width="20" height="24" style="top:-8px;left:50px;">
          <line x1="12" y1="28" x2="12" y2="12" stroke="#00b894" stroke-width="2" stroke-linecap="round"/>
          <ellipse cx="8" cy="10" rx="6" ry="4" fill="#55efc4" transform="rotate(-20,8,10)"/>
          <ellipse cx="16" cy="8" rx="5" ry="3.5" fill="#00b894" transform="rotate(15,16,8)"/>
          <circle cx="12" cy="5" r="2" fill="#55efc4" opacity="0.6">
            <animate attributeName="r" values="1.5;2.5;1.5" dur="2s" repeatCount="indefinite"/>
          </circle>
        </svg>`,
        particles: {
          items: [
            `<span style="color:#55efc4;font-size:11px">&#127793;</span>`,
            SVG.dot("#00b894"), SVG.dot("#55efc4"),
            `<span style="color:#00b894;font-size:10px">&#127807;</span>`,
          ],
          anim: "sway-float", rate: 1000,
        },
      },

      "thinking-magical": {
        labels: ["wizarding...", "enchanting...", "divining...", "manifesting...", "channelling..."],
        label: "wizarding...",
        // Wizard hat + wand
        accessory: `<svg viewBox="0 0 36 36" width="32" height="32" style="top:-6px;left:30px;">
          <polygon points="18,0 8,28 28,28" fill="#6c5ce7" stroke="#a29bfe" stroke-width="0.8"/>
          <ellipse cx="18" cy="28" rx="14" ry="3" fill="#6c5ce7"/>
          <circle cx="18" cy="8" r="2.5" fill="#ffd700">
            <animate attributeName="r" values="2;3;2" dur="1.5s" repeatCount="indefinite"/>
            <animate attributeName="opacity" values="0.7;1;0.7" dur="1.5s" repeatCount="indefinite"/>
          </circle>
          <line x1="30" y1="20" x2="36" y2="8" stroke="#f9ca24" stroke-width="1.5" stroke-linecap="round"/>
          <circle cx="36" cy="7" r="2" fill="#ffd700">
            <animate attributeName="r" values="1.5;2.5;1.5" dur="0.8s" repeatCount="indefinite"/>
          </circle>
        </svg>`,
        particles: {
          items: [SVG.sparkle("#ffd700"), SVG.star("#a29bfe"), SVG.sparkle("#f9ca24"), SVG.star("#d5ccff")],
          anim: "orbit", rate: 500,
        },
      },

      "thinking-silly": {
        labels: ["booping...", "frolicking...", "wibbling...", "combobulating...", "jiving...", "vibing..."],
        label: "booping...",
        // Party hat
        accessory: `<svg viewBox="0 0 24 28" width="20" height="24" style="top:-4px;left:48px;">
          <polygon points="12,0 4,24 20,24" fill="#fd79a8"/>
          <line x1="4" y1="10" x2="20" y2="10" stroke="#ffeaa7" stroke-width="1.5"/>
          <line x1="4" y1="16" x2="20" y2="16" stroke="#74b9ff" stroke-width="1.5"/>
          <circle cx="12" cy="0" r="3" fill="#ffeaa7">
            <animate attributeName="r" values="2;3.5;2" dur="1s" repeatCount="indefinite"/>
          </circle>
        </svg>`,
        particles: {
          items: [
            SVG.dot("#fd79a8"), SVG.dot("#74b9ff"), SVG.dot("#ffeaa7"),
            SVG.tri("#55efc4"), SVG.diamond("#fdcb6e"), SVG.dot("#a29bfe"),
          ],
          anim: "pop-up", rate: 300,
        },
      },

      "thinking-exploring": {
        labels: ["spelunking...", "wandering...", "meandering...", "perusing...", "elucidating..."],
        label: "spelunking...",
        // Lantern
        accessory: `<svg viewBox="0 0 20 28" width="18" height="24" style="top:30px;left:88px;">
          <rect x="6" y="4" width="8" height="3" rx="1" fill="#636e72"/>
          <rect x="4" y="7" width="12" height="14" rx="2" fill="#fdcb6e" opacity="0.3" stroke="#f0932b" stroke-width="0.8"/>
          <ellipse cx="10" cy="14" rx="3" ry="4" fill="#ffd700" opacity="0.8">
            <animate attributeName="opacity" values="0.6;1;0.6" dur="1.5s" repeatCount="indefinite"/>
          </ellipse>
          <rect x="4" y="21" width="12" height="2" rx="1" fill="#636e72"/>
          <line x1="10" y1="1" x2="10" y2="4" stroke="#636e72" stroke-width="1.5" stroke-linecap="round"/>
        </svg>`,
        particles: {
          items: [SVG.dot("#f0932b"), SVG.dot("#fdcb6e"), SVG.dot("#dfe6e9"), SVG.sparkle("#ffeaa7")],
          anim: "sway-float", rate: 900,
        },
      },

      "debugging-detective": {
        label: "detective! (debugging)",
        // Deerstalker hat
        accessory: `<svg viewBox="0 0 40 22" width="36" height="18" style="top:2px;left:30px;">
          <ellipse cx="20" cy="18" rx="18" ry="4" fill="#8B6914"/>
          <ellipse cx="20" cy="12" rx="14" ry="8" fill="#b8860b"/>
          <ellipse cx="20" cy="10" rx="12" ry="6" fill="#d4a020"/>
          <rect x="4" y="14" width="6" height="6" rx="2" fill="#b8860b" transform="rotate(-15,7,17)"/>
          <rect x="30" y="14" width="6" height="6" rx="2" fill="#b8860b" transform="rotate(15,33,17)"/>
        </svg>`,
        particles: {
          items: [
            `<span style="color:#f0932b;font-size:13px">&#128065;</span>`,
            SVG.sparkle("#fdcb6e"), SVG.dot("#f0932b"),
            `<span style="color:#8B6914;font-size:10px">&#9737;</span>`,
          ],
          anim: "wiggle-float", rate: 1000,
        },
      },

      "debugging-rage": {
        label: "RAGE! (debugging)",
        accessory: null,
        particles: {
          items: [
            `<span style="color:#ff4757;font-size:14px;font-weight:bold">&#128545;</span>`,
            `<span style="color:#ff6348;font-size:11px;font-weight:bold">!!</span>`,
            SVG.cross("#ff4757"), SVG.bolt("#ff6348"),
            SVG.cloud("#b2bec3"),
          ],
          anim: "pop-up", rate: 400,
        },
      },

      "searching-treasure": {
        label: "treasure hunt! (searching)",
        // Treasure map
        accessory: `<svg viewBox="0 0 30 24" width="26" height="22" style="top:-6px;left:72px;">
          <rect x="2" y="2" width="26" height="20" rx="2" fill="#ffeaa7" stroke="#f0932b" stroke-width="1"/>
          <path d="M6,8 L10,12 L18,6 L22,16" fill="none" stroke="#d4a020" stroke-width="1.5" stroke-linecap="round" stroke-dasharray="3 2"/>
          <circle cx="22" cy="16" r="2" fill="#ff6b6b">
            <animate attributeName="r" values="1.5;2.5;1.5" dur="1s" repeatCount="indefinite"/>
          </circle>
          <text x="21" y="18" font-size="5" fill="#c0392b" font-weight="bold">X</text>
        </svg>`,
        particles: {
          items: [SVG.sparkle("#ffd700"), SVG.star("#f9ca24"), SVG.diamond("#ffd700"), SVG.sparkle("#f0932b")],
          anim: "sway-float", rate: 700,
        },
      },

      "searching-deep": {
        label: "deep dive! (searching)",
        // Diving goggles
        accessory: `<svg viewBox="0 0 44 18" width="38" height="16" style="top:32px;left:28px;">
          <circle cx="12" cy="9" r="7" fill="rgba(116,185,255,0.2)" stroke="#0984e3" stroke-width="1.5"/>
          <circle cx="32" cy="9" r="7" fill="rgba(116,185,255,0.2)" stroke="#0984e3" stroke-width="1.5"/>
          <path d="M19,9 Q22,12 25,9" stroke="#0984e3" stroke-width="1.5" fill="none"/>
          <line x1="5" y1="6" x2="1" y2="5" stroke="#0984e3" stroke-width="1.2"/>
          <line x1="39" y1="6" x2="43" y2="5" stroke="#0984e3" stroke-width="1.2"/>
        </svg>`,
        particles: {
          items: [
            SVG.dot("#74b9ff"), SVG.ring("#0984e3"),
            SVG.dot("#a29bfe"), SVG.dot("#55efc4"),
          ],
          anim: "float-up", rate: 600,
        },
      },

      "reading-scholar": {
        label: "scholar! (reading)",
        // Book stack + glasses
        accessory: `<svg viewBox="0 0 36 36" width="30" height="30" style="top:60px;left:42px;">
          <rect x="2" y="22" width="32" height="5" rx="1" fill="#e17055" stroke="#d63031" stroke-width="0.5"/>
          <rect x="4" y="17" width="28" height="5" rx="1" fill="#0984e3" stroke="#0652DD" stroke-width="0.5"/>
          <rect x="3" y="12" width="30" height="5" rx="1" fill="#6c5ce7" stroke="#4834d4" stroke-width="0.5"/>
          <path d="M3,7 L17,5 L17,12 L3,12Z" fill="#a29bfe" stroke="#6c5ce7" stroke-width="0.5"/>
          <path d="M17,5 L33,7 L33,12 L17,12Z" fill="#d5ccff" stroke="#6c5ce7" stroke-width="0.5"/>
          <line x1="17" y1="5" x2="17" y2="12" stroke="#6c5ce7" stroke-width="1"/>
        </svg>`,
        particles: {
          items: [SVG.page("#a29bfe"), SVG.page("#6c5ce7"), SVG.sparkle("#d5ccff"), SVG.star("#a29bfe")],
          anim: "sway-float", rate: 1200,
        },
      },

      "reading-ancient": {
        label: "ancient scroll! (reading)",
        // Glowing scroll
        accessory: `<svg viewBox="0 0 36 32" width="30" height="26" style="top:62px;left:42px;">
          <rect x="6" y="4" width="24" height="24" fill="#ffeaa7" stroke="#d4a020" stroke-width="1"/>
          <circle cx="6" cy="4" r="4" fill="#f0d070" stroke="#d4a020" stroke-width="0.8"/>
          <circle cx="6" cy="28" r="4" fill="#f0d070" stroke="#d4a020" stroke-width="0.8"/>
          <circle cx="30" cy="4" r="4" fill="#f0d070" stroke="#d4a020" stroke-width="0.8"/>
          <circle cx="30" cy="28" r="4" fill="#f0d070" stroke="#d4a020" stroke-width="0.8"/>
          <text x="10" y="14" font-size="6" fill="#d4a020" font-family="serif" opacity="0.7">&#x2625;</text>
          <text x="20" y="14" font-size="6" fill="#d4a020" font-family="serif" opacity="0.7">&#x2626;</text>
          <text x="14" y="22" font-size="6" fill="#d4a020" font-family="serif" opacity="0.7">&#x2627;</text>
          <rect x="6" y="4" width="24" height="24" fill="#ffd700" opacity="0">
            <animate attributeName="opacity" values="0;0.15;0" dur="2s" repeatCount="indefinite"/>
          </rect>
        </svg>`,
        particles: {
          items: [
            `<span style="color:#d4a020;font-size:12px;font-family:serif;opacity:0.8">&#x2625;</span>`,
            `<span style="color:#f0d070;font-size:11px;font-family:serif;opacity:0.7">&#x2626;</span>`,
            SVG.sparkle("#ffd700"), SVG.star("#d4a020"),
          ],
          anim: "sway-float", rate: 900,
        },
      },

      "testing-scientist": {
        label: "science! (testing)",
        // Bubbling test tube
        accessory: `<svg viewBox="0 0 20 34" width="16" height="28" style="top:-8px;left:80px;">
          <rect x="6" y="0" width="8" height="4" rx="1" fill="#b2bec3"/>
          <path d="M6,4 L4,26 Q4,30 10,30 Q16,30 16,26 L14,4Z" fill="rgba(116,185,255,0.3)" stroke="#0984e3" stroke-width="1"/>
          <ellipse cx="10" cy="24" rx="5" ry="3" fill="#2ecc71" opacity="0.6">
            <animate attributeName="opacity" values="0.4;0.7;0.4" dur="1.5s" repeatCount="indefinite"/>
          </ellipse>
          <ellipse cx="10" cy="20" rx="4" ry="2" fill="#a29bfe" opacity="0.5">
            <animate attributeName="cy" values="20;18;20" dur="2s" repeatCount="indefinite"/>
          </ellipse>
          <circle cx="8" cy="16" r="1.5" fill="#ff6b6b" opacity="0.6">
            <animate attributeName="cy" values="16;12;16" dur="1.8s" repeatCount="indefinite"/>
          </circle>
          <circle cx="12" cy="14" r="1" fill="#f9ca24" opacity="0.5">
            <animate attributeName="cy" values="14;10;14" dur="2.2s" repeatCount="indefinite"/>
          </circle>
        </svg>`,
        particles: {
          items: [SVG.dot("#2ecc71"), SVG.dot("#a29bfe"), SVG.dot("#ff6b6b"), SVG.dot("#f9ca24"), SVG.sparkle("#00cec9")],
          anim: "float-up", rate: 700,
        },
      },

      "testing-perfectionist": {
        label: "100% coverage! (testing)",
        // Green glowing clipboard
        accessory: `<svg viewBox="0 0 28 34" width="22" height="26" style="top:-8px;left:76px;">
          <rect x="2" y="4" width="24" height="28" rx="2" fill="#2ecc71" stroke="#00b894" stroke-width="1.2"/>
          <rect x="8" y="0" width="12" height="6" rx="2" fill="#00b894"/>
          <rect x="10" y="1.5" width="8" height="3" rx="1" fill="#2ecc71"/>
          <path d="M6,13 L8.5,15.5 L13,11" fill="none" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          <path d="M6,20 L8.5,22.5 L13,18" fill="none" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          <path d="M6,27 L8.5,29.5 L13,25" fill="none" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          <text x="15" y="16" font-size="7" fill="#fff" font-weight="bold" font-family="monospace">&#10003;</text>
          <text x="15" y="23" font-size="7" fill="#fff" font-weight="bold" font-family="monospace">&#10003;</text>
          <text x="15" y="30" font-size="7" fill="#fff" font-weight="bold" font-family="monospace">&#10003;</text>
        </svg>`,
        particles: {
          items: [SVG.check("#2ecc71"), SVG.check("#00b894"), SVG.check("#55efc4"), SVG.star("#2ecc71"), SVG.sparkle("#00b894")],
          anim: "rain-down", rate: 500,
        },
      },

      "deploying-warp": {
        label: "warp speed! (deploying)",
        // Speed lines
        accessory: `<svg viewBox="0 0 80 60" width="70" height="52" style="top:10px;left:24px;">
          <line x1="0" y1="20" x2="25" y2="20" stroke="#ff7675" stroke-width="2" opacity="0.6">
            <animate attributeName="x1" values="-10;30;-10" dur="0.8s" repeatCount="indefinite"/>
            <animate attributeName="x2" values="15;55;15" dur="0.8s" repeatCount="indefinite"/>
          </line>
          <line x1="5" y1="30" x2="30" y2="30" stroke="#fdcb6e" stroke-width="1.5" opacity="0.5">
            <animate attributeName="x1" values="-5;35;-5" dur="0.6s" repeatCount="indefinite"/>
            <animate attributeName="x2" values="20;60;20" dur="0.6s" repeatCount="indefinite"/>
          </line>
          <line x1="0" y1="40" x2="20" y2="40" stroke="#ff7675" stroke-width="2" opacity="0.6">
            <animate attributeName="x1" values="-15;25;-15" dur="0.7s" repeatCount="indefinite"/>
            <animate attributeName="x2" values="10;50;10" dur="0.7s" repeatCount="indefinite"/>
          </line>
          <line x1="55" y1="25" x2="80" y2="25" stroke="#fdcb6e" stroke-width="1.5" opacity="0.5">
            <animate attributeName="x1" values="50;20;50" dur="0.7s" repeatCount="indefinite"/>
            <animate attributeName="x2" values="75;45;75" dur="0.7s" repeatCount="indefinite"/>
          </line>
          <line x1="60" y1="35" x2="80" y2="35" stroke="#ff7675" stroke-width="2" opacity="0.6">
            <animate attributeName="x1" values="55;25;55" dur="0.65s" repeatCount="indefinite"/>
            <animate attributeName="x2" values="80;50;80" dur="0.65s" repeatCount="indefinite"/>
          </line>
        </svg>`,
        particles: {
          items: [SVG.bolt("#fdcb6e"), SVG.bolt("#ff7675"), SVG.sparkle("#e17055"), SVG.sparkle("#fdcb6e")],
          anim: "float-up", rate: 250,
        },
      },

      "deploying-satellite": {
        label: "to the moon! (deploying)",
        // Moon + orbiting satellite
        accessory: `<svg viewBox="0 0 60 60" width="50" height="50" style="top:-20px;left:34px;">
          <circle cx="30" cy="30" r="12" fill="#ffeaa7" stroke="#f0d070" stroke-width="1"/>
          <circle cx="26" cy="26" r="3" fill="#f0d070" opacity="0.5"/>
          <circle cx="34" cy="32" r="2" fill="#f0d070" opacity="0.4"/>
          <circle cx="28" cy="34" r="1.5" fill="#f0d070" opacity="0.3"/>
          <g>
            <animateTransform attributeName="transform" type="rotate" values="0 30 30;360 30 30" dur="4s" repeatCount="indefinite"/>
            <rect x="48" y="28" width="6" height="4" rx="1" fill="#b2bec3" stroke="#636e72" stroke-width="0.5"/>
            <line x1="46" y1="30" x2="48" y2="30" stroke="#74b9ff" stroke-width="0.8"/>
            <line x1="54" y1="30" x2="56" y2="30" stroke="#74b9ff" stroke-width="0.8"/>
          </g>
        </svg>`,
        particles: {
          items: [SVG.star("#ffeaa7"), SVG.sparkle("#f0d070"), SVG.dot("#74b9ff"), SVG.star("#a29bfe")],
          anim: "orbit", rate: 800,
        },
      },

      // â”€â”€ EXTENDED â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      searching: {
        label: "searching...",
        // Animated magnifying glass that bobs with the body
        accessory: `<svg viewBox="0 0 32 32" width="26" height="26" style="top:-4px;left:72px;animation:search-peer 1.2s ease-in-out infinite;">
          <circle cx="13" cy="13" r="9" fill="none" stroke="#0984e3" stroke-width="2.5"/>
          <circle cx="13" cy="13" r="5" fill="#74b9ff" opacity="0.25">
            <animate attributeName="opacity" values="0.15;0.4;0.15" dur="1.5s" repeatCount="indefinite"/>
          </circle>
          <line x1="20" y1="20" x2="29" y2="29" stroke="#0984e3" stroke-width="3" stroke-linecap="round"/>
        </svg>`,
        particles: {
          items: [SVG.dot("#74b9ff"), SVG.ring("#0984e3"), SVG.sparkle("#a29bfe"), SVG.dot("#a29bfe")],
          anim: "orbit", rate: 800,
        },
      },

      reading: {
        label: "reading...",
        // Open book with page-turn shimmer
        accessory: `<svg viewBox="0 0 36 28" width="30" height="24" style="top:68px;left:42px;">
          <path d="M2,4 L17,2 L17,24 L2,22Z" fill="#a29bfe" stroke="#6c5ce7" stroke-width="1"/>
          <path d="M17,2 L32,4 L32,22 L17,24Z" fill="#d5ccff" stroke="#6c5ce7" stroke-width="1"/>
          <line x1="17" y1="2" x2="17" y2="24" stroke="#6c5ce7" stroke-width="1.5"/>
          <line x1="5" y1="8" x2="14" y2="7" stroke="#fff" stroke-width="1" opacity="0.6"/>
          <line x1="5" y1="12" x2="14" y2="11" stroke="#fff" stroke-width="1" opacity="0.6"/>
          <line x1="5" y1="16" x2="12" y2="15" stroke="#fff" stroke-width="1" opacity="0.6"/>
          <line x1="20" y1="7" x2="29" y2="8" stroke="#6c5ce7" stroke-width="1" opacity="0.3"/>
          <line x1="20" y1="11" x2="29" y2="12" stroke="#6c5ce7" stroke-width="1" opacity="0.3"/>
          <rect x="17" y="2" width="15" height="22" fill="#fff" opacity="0">
            <animate attributeName="opacity" values="0;0.15;0" dur="3s" repeatCount="indefinite"/>
          </rect>
        </svg>`,
        particles: {
          items: [SVG.page("#a29bfe"), SVG.sparkle("#6c5ce7"), SVG.dot("#d5ccff")],
          anim: "sway-float", rate: 1400,
        },
      },

      debugging: {
        label: "debugging!",
        // Bug orbiting the creature
        accessory: `<svg viewBox="0 0 24 24" width="22" height="22" style="top:8px;left:84px;animation:orbit 3s linear infinite;">
          <ellipse cx="12" cy="14" rx="5" ry="6.5" fill="#e84393"/>
          <circle cx="12" cy="7" r="3.5" fill="#e84393"/>
          <circle cx="10.5" cy="6" r="1.2" fill="#fff"/>
          <circle cx="13.5" cy="6" r="1.2" fill="#fff"/>
          <circle cx="10.5" cy="6" r="0.6" fill="#2c1810"/>
          <circle cx="13.5" cy="6" r="0.6" fill="#2c1810"/>
          <line x1="7" y1="11" x2="4" y2="8" stroke="#e84393" stroke-width="1.2" stroke-linecap="round"/>
          <line x1="17" y1="11" x2="20" y2="8" stroke="#e84393" stroke-width="1.2" stroke-linecap="round"/>
          <line x1="7" y1="16" x2="4" y2="18" stroke="#e84393" stroke-width="1.2" stroke-linecap="round"/>
          <line x1="17" y1="16" x2="20" y2="18" stroke="#e84393" stroke-width="1.2" stroke-linecap="round"/>
        </svg>`,
        particles: {
          items: [SVG.bug("#fd79a8"), SVG.cross("#e84393"), SVG.sparkle("#ff7675")],
          anim: "wiggle-float", rate: 900,
        },
      },

      installing: {
        label: "installing...",
        // Animated progress bar
        accessory: `<svg viewBox="0 0 60 14" width="54" height="12" style="top:-12px;left:33px;">
          <rect x="0" y="0" width="54" height="12" rx="6" fill="rgba(0,0,0,0.3)"/>
          <rect x="2" y="2" width="10" height="8" rx="4" fill="#00cec9">
            <animate attributeName="width" values="5;50;5" dur="2s" repeatCount="indefinite"/>
          </rect>
          <rect x="2" y="2" width="50" height="8" rx="4" fill="none" stroke="#00b894" stroke-width="0.5" opacity="0.4"/>
        </svg>`,
        particles: {
          items: [SVG.gear("#00cec9"), SVG.diamond("#00b894"), SVG.dot("#55efc4")],
          anim: "float-up", rate: 1000,
        },
      },

      testing: {
        label: "testing...",
        // Clipboard with animated checkmarks appearing sequentially
        accessory: `<svg viewBox="0 0 28 34" width="22" height="26" style="top:-8px;left:76px;">
          <rect x="2" y="4" width="24" height="28" rx="2" fill="#ffeaa7" stroke="#fdcb6e" stroke-width="1.2"/>
          <rect x="8" y="0" width="12" height="6" rx="2" fill="#f0932b"/>
          <rect x="10" y="1.5" width="8" height="3" rx="1" fill="#ffeaa7"/>
          <path d="M6,13 L8.5,15.5 L13,11" fill="none" stroke="#00b894" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" stroke-dasharray="12" stroke-dashoffset="12">
            <animate attributeName="stroke-dashoffset" values="12;0;0" dur="2s" repeatCount="indefinite"/>
          </path>
          <line x1="15" y1="13" x2="22" y2="13" stroke="#2d3436" stroke-width="1.2" stroke-linecap="round"/>
          <path d="M6,20 L8.5,22.5 L13,18" fill="none" stroke="#00b894" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" stroke-dasharray="12" stroke-dashoffset="12">
            <animate attributeName="stroke-dashoffset" values="12;12;0;0" dur="2s" repeatCount="indefinite"/>
          </path>
          <line x1="15" y1="20" x2="20" y2="20" stroke="#2d3436" stroke-width="1.2" stroke-linecap="round"/>
          <circle cx="9" cy="27.5" r="2" fill="none" stroke="#fdcb6e" stroke-width="1.5" stroke-dasharray="4 8">
            <animateTransform attributeName="transform" type="rotate" values="0 9 27.5;360 9 27.5" dur="1s" repeatCount="indefinite"/>
          </circle>
          <line x1="15" y1="27" x2="22" y2="27" stroke="#b2bec3" stroke-width="1.2" stroke-linecap="round"/>
        </svg>`,
        particles: {
          items: [SVG.check("#00b894"), SVG.check("#00cec9"), SVG.cross("#fdcb6e"), SVG.sparkle("#ffeaa7")],
          anim: "pop-up", rate: 900,
        },
      },

      deploying: {
        label: "deploying!",
        // Rocket ship with animated exhaust flames
        accessory: `<svg viewBox="0 0 24 44" width="18" height="34" style="top:-20px;left:48px;animation:deploy-launch 1.5s ease-in-out infinite;">
          <ellipse cx="12" cy="14" rx="7" ry="14" fill="#dfe6e9"/>
          <ellipse cx="12" cy="10" rx="5" ry="8" fill="#74b9ff"/>
          <circle cx="12" cy="10" r="3" fill="#0984e3"/>
          <circle cx="12" cy="10" r="1.5" fill="#fff" opacity="0.6"/>
          <path d="M5,18 L2,26 L7,22Z" fill="#e17055"/>
          <path d="M19,18 L22,26 L17,22Z" fill="#e17055"/>
          <ellipse cx="12" cy="28" rx="4" ry="2" fill="#fdcb6e"/>
          <path d="M9,28 L8,36 L12,32 L16,36 L15,28" fill="#e17055" opacity="0.8">
            <animate attributeName="d" values="M9,28 L8,36 L12,32 L16,36 L15,28;M9,28 L7,40 L12,34 L17,40 L15,28;M9,28 L8,36 L12,32 L16,36 L15,28" dur="0.3s" repeatCount="indefinite"/>
          </path>
          <path d="M10,30 L9,38 L12,35 L15,38 L14,30" fill="#fdcb6e" opacity="0.7">
            <animate attributeName="d" values="M10,30 L9,38 L12,35 L15,38 L14,30;M10,30 L8,42 L12,37 L16,42 L14,30;M10,30 L9,38 L12,35 L15,38 L14,30" dur="0.25s" repeatCount="indefinite"/>
          </path>
        </svg>`,
        particles: {
          items: [SVG.bolt("#fdcb6e"), SVG.star("#ff7675"), SVG.sparkle("#e17055"), SVG.sparkle("#fdcb6e")],
          anim: "float-up", rate: 300,
        },
      },

      cooking: {
        label: "cooking...",
        // Chef hat
        accessory: `<svg viewBox="0 0 40 28" width="36" height="24" style="top:-8px;left:38px;">
          <ellipse cx="20" cy="20" rx="16" ry="5" fill="#fff" stroke="#dfe6e9" stroke-width="1"/>
          <ellipse cx="12" cy="12" rx="8" ry="9" fill="#fff"/>
          <ellipse cx="28" cy="12" rx="8" ry="9" fill="#fff"/>
          <ellipse cx="20" cy="8" rx="9" ry="9" fill="#fff"/>
          <rect x="6" y="15" width="28" height="6" fill="#fff"/>
          <ellipse cx="20" cy="20" rx="16" ry="5" fill="none" stroke="#dfe6e9" stroke-width="1"/>
        </svg>`,
        particles: {
          items: [SVG.cloud("#dfe6e9"), SVG.cloud("#b2bec3"), SVG.sparkle("#fdcb6e")],
          anim: "sway-float", rate: 700,
        },
      },

      hatching: {
        label: "hatching...",
        // Cracking egg under the creature
        accessory: `<svg viewBox="0 0 50 38" width="44" height="34" style="top:56px;left:36px;animation:crack-shake 1s ease-in-out infinite;">
          <ellipse cx="25" cy="22" rx="20" ry="16" fill="#ffeaa7" stroke="#f0932b" stroke-width="1.2"/>
          <ellipse cx="25" cy="22" rx="20" ry="16" fill="none" stroke="#fdcb6e" stroke-width="0.8"/>
          <path d="M12,16 L16,8 L20,16 L25,6 L30,16 L34,10 L38,16" fill="none" stroke="#f0932b" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
          <line x1="21" y1="14" x2="23" y2="22" stroke="#f0932b" stroke-width="0.8" opacity="0.5"/>
          <line x1="28" y1="12" x2="27" y2="20" stroke="#f0932b" stroke-width="0.8" opacity="0.5"/>
          <line x1="18" y1="16" x2="19" y2="20" stroke="#f0932b" stroke-width="0.8" opacity="0.4"/>
        </svg>`,
        particles: {
          items: [SVG.sparkle("#fdcb6e"), SVG.star("#ffeaa7"), SVG.dot("#f0932b")],
          anim: "pop-up", rate: 1500,
        },
      },

      deleting: {
        label: "cleaning up...",
        // Broom
        accessory: `<svg viewBox="0 0 18 38" width="14" height="30" style="top:14px;left:92px;animation:delete-sweep 0.6s ease-in-out infinite;">
          <rect x="7" y="0" width="4" height="24" rx="2" fill="#b2bec3"/>
          <rect x="0" y="22" width="18" height="14" rx="3" fill="#636e72"/>
          <line x1="3" y1="26" x2="3" y2="34" stroke="#2d3436" stroke-width="1" stroke-linecap="round"/>
          <line x1="7" y1="26" x2="7" y2="35" stroke="#2d3436" stroke-width="1" stroke-linecap="round"/>
          <line x1="11" y1="26" x2="11" y2="35" stroke="#2d3436" stroke-width="1" stroke-linecap="round"/>
          <line x1="15" y1="26" x2="15" y2="34" stroke="#2d3436" stroke-width="1" stroke-linecap="round"/>
        </svg>`,
        particles: {
          items: [SVG.dust("#b2bec3"), SVG.cross("#636e72"), SVG.dot("#dfe6e9")],
          anim: "wiggle-float", rate: 800,
        },
      },

      downloading: {
        label: "downloading...",
        // Progress bar (blue variant)
        accessory: `<svg viewBox="0 0 60 14" width="54" height="12" style="top:-12px;left:33px;">
          <rect x="0" y="0" width="54" height="12" rx="6" fill="rgba(0,0,0,0.3)"/>
          <rect x="2" y="2" width="10" height="8" rx="4" fill="#74b9ff">
            <animate attributeName="width" values="5;50;5" dur="3s" repeatCount="indefinite"/>
          </rect>
          <rect x="2" y="2" width="50" height="8" rx="4" fill="none" stroke="#0984e3" stroke-width="0.5" opacity="0.4"/>
        </svg>`,
        particles: {
          items: [SVG.page("#74b9ff"), SVG.arrowDown("#0984e3"), SVG.dot("#a29bfe")],
          anim: "rain-down", rate: 600,
        },
      },
    };

    // â”€â”€ IDLE MOOD CYCLING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const IDLE_VARIANTS = ["idle", "idle-vibing", "idle-sleepy", "idle-coffee", "idle-stargazing"];
    const RARE_IDLE_VARIANTS = [
      { key: "idle-stretching", chance: 0.08 },
      { key: "idle-dancing",    chance: 0.08 },
      { key: "idle-butterfly",  chance: 0.05 },
      { key: "idle-juggling",   chance: 0.05 },
      { key: "idle-rainbow",    chance: 0.02 },
      { key: "idle-meditation", chance: 0.02 },
    ];
    // Activity rare variants â€” roll once on state entry, persist for duration
    const ACTIVITY_RARE_VARIANTS = {
      coding: [
        { key: "coding-flow",    chance: 0.12 },
        { key: "coding-hacking", chance: 0.04 },
      ],
      thinking: [
        { key: "thinking-eureka", chance: 0.12 },
        { key: "thinking-galaxy", chance: 0.04 },
      ],
      debugging: [
        { key: "debugging-detective", chance: 0.12 },
        { key: "debugging-rage",      chance: 0.04 },
      ],
      searching: [
        { key: "searching-treasure", chance: 0.12 },
        { key: "searching-deep",     chance: 0.04 },
      ],
      reading: [
        { key: "reading-scholar", chance: 0.12 },
        { key: "reading-ancient", chance: 0.04 },
      ],
      testing: [
        { key: "testing-scientist",     chance: 0.12 },
        { key: "testing-perfectionist", chance: 0.04 },
      ],
      deploying: [
        { key: "deploying-warp",      chance: 0.12 },
        { key: "deploying-satellite", chance: 0.04 },
      ],
    };

    // Themed thinking variants â€” picked when no rare variant triggers
    const THINKING_THEMES = [
      "thinking-cooking", "thinking-action", "thinking-creating",
      "thinking-processing", "thinking-growing", "thinking-magical",
      "thinking-silly", "thinking-exploring",
    ];

    let currentBaseState = null; // tracks the base activity to prevent re-rolling
    let currentActivityVariant = null; // the rolled variant key (or null)

    let idleCycleTimer = null;
    let idleCycleIndex = 0;

    function startIdleCycle() {
      stopIdleCycle();
      idleCycleIndex = 0;
      applyIdleMood();
      idleCycleTimer = setInterval(() => {
        idleCycleIndex = (idleCycleIndex + 1) % IDLE_VARIANTS.length;
        applyIdleMood();
      }, 45000);
    }

    function applyIdleMood() {
      // Roll for a rare idle variant (30% total chance)
      const roll = Math.random();
      let cumulative = 0;
      let rareVariant = null;
      for (const rv of RARE_IDLE_VARIANTS) {
        cumulative += rv.chance;
        if (roll < cumulative) {
          rareVariant = rv.key;
          break;
        }
      }

      let variant, config;
      if (rareVariant) {
        variant = rareVariant;
        config = ANIMATIONS[variant];
        ipcRenderer.send("idle-variant-change", variant);
      } else {
        variant = IDLE_VARIANTS[idleCycleIndex];
        config = ANIMATIONS[variant];
        ipcRenderer.send("idle-variant-change", "idle");
      }

      scene.className = buildSceneClassName(variant);
      label.textContent = config.label;
      currentState = variant;
      dbg("idle-mood", { variant, rare: !!rareVariant });
      updateAccessories(config);
      updateParticles(config);
      updateSkillLabel();
    }

    function stopIdleCycle() {
      if (idleCycleTimer) {
        clearInterval(idleCycleTimer);
        idleCycleTimer = null;
      }
    }

    // â”€â”€ STATE MANAGEMENT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function setState(state) {
      dbg("set-state", { state, prevState: currentState });
      const baseConfig = ANIMATIONS[state] || ANIMATIONS["thinking"];
      const baseState = ANIMATIONS[state] ? state : "thinking";

      const wasIdle = currentState.startsWith("idle");
      const goingIdle = baseState === "idle";

      if (!goingIdle && wasIdle) stopIdleCycle();
      if (goingIdle && !wasIdle) {
        currentBaseState = null;
        currentActivityVariant = null;
        ipcRenderer.send("activity-variant-change", null);
        startIdleCycle();
        return;
      }
      if (goingIdle && wasIdle) return;

      // Same base state as before â€” keep current variant, don't re-roll
      if (baseState === currentBaseState) return;

      // New base state â€” roll for a rare variant
      currentBaseState = baseState;
      currentActivityVariant = null;

      let effectiveState = baseState;
      let config = baseConfig;

      const variants = ACTIVITY_RARE_VARIANTS[baseState];
      if (variants) {
        const roll = Math.random();
        let cumulative = 0;
        for (const rv of variants) {
          cumulative += rv.chance;
          if (roll < cumulative) {
            effectiveState = rv.key;
            config = ANIMATIONS[rv.key] || baseConfig;
            currentActivityVariant = rv.key;
            break;
          }
        }
      }

      // If base state is "thinking" and no rare variant hit, pick a random theme
      if (baseState === "thinking" && !currentActivityVariant) {
        const theme = THINKING_THEMES[Math.floor(Math.random() * THINKING_THEMES.length)];
        effectiveState = theme;
        config = ANIMATIONS[theme];
        // Pick random label from pool
        if (config.labels) {
          const picked = config.labels[Math.floor(Math.random() * config.labels.length)];
          config = { ...config, label: picked.replace("...", " (thinking)") };
        }
      }

      ipcRenderer.send("activity-variant-change", currentActivityVariant);

      scene.className = buildSceneClassName(effectiveState);
      label.textContent = config.label || effectiveState;
      currentState = effectiveState;

      updateAccessories(config);
      updateParticles(config);
      updateSkillLabel();
    }

    function updateAccessories(config) {
      // Accessories were designed for the 120px CSS blob â€” not used with Anu sprite
      accessoryLayer.innerHTML = "";
      dbg("accessory-clear", { state: currentState });
    }

    function updateParticles(config) {
      if (particleInterval) {
        clearInterval(particleInterval);
        particleInterval = null;
      }
      particleLayer.innerHTML = "";
      if (!config.particles) return;

      const { items, anim, rate } = config.particles;
      let idx = 0;

      function spawnParticle() {
        const el = document.createElement("div");
        el.className = "p";
        el.innerHTML = items[idx % items.length];
        idx++;

        const x = 10 + Math.random() * 120;
        el.style.left = x + "px";
        el.style.top = "60px";
        el.style.animation = `${anim} ${1.5 + Math.random() * 1}s ease-out forwards`;
        el.style.animationDelay = (Math.random() * 0.3) + "s";

        particleLayer.appendChild(el);
        setTimeout(() => { if (el.parentNode) el.parentNode.removeChild(el); }, 3500);
      }

      spawnParticle();
      particleInterval = setInterval(spawnParticle, rate);
    }

    // â”€â”€ PROGRESSION UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    const TIER_BADGE_COLORS = [
      "rgba(0,0,0,0.5)",    // Hatchling
      "#cd7f32",            // Apprentice (copper)
      "#7ba3bf",            // Adept (silver-blue)
      "#d4a020",            // Expert (gold)
      "#c77f84",            // Master (rose gold)
      "#6c5ce7",            // Legendary (purple)
    ];

    // Milestone accessories: { key, condition(skills, level), svg }
    const MILESTONES = [
      {
        key: "glasses",
        test: (s, l) => s.coding && s.coding.level >= 5,
        svg: `<svg viewBox="0 0 40 16" width="36" height="14" style="top:38px;left:32px;">
          <circle cx="12" cy="8" r="6" fill="none" stroke="#2c1810" stroke-width="1.5"/>
          <circle cx="28" cy="8" r="6" fill="none" stroke="#2c1810" stroke-width="1.5"/>
          <line x1="18" y1="8" x2="22" y2="8" stroke="#2c1810" stroke-width="1.5"/>
          <line x1="6" y1="8" x2="2" y2="6" stroke="#2c1810" stroke-width="1"/>
          <line x1="34" y1="8" x2="38" y2="6" stroke="#2c1810" stroke-width="1"/>
          <circle cx="12" cy="8" r="6" fill="rgba(116,185,255,0.1)"/>
          <circle cx="28" cy="8" r="6" fill="rgba(116,185,255,0.1)"/>
        </svg>`,
      },
      {
        key: "magnifier",
        test: (s, l) => s.debugging && s.debugging.level >= 3,
        svg: `<svg viewBox="0 0 18 18" width="14" height="14" style="top:14px;left:96px;">
          <circle cx="8" cy="8" r="5" fill="none" stroke="#e84393" stroke-width="1.5"/>
          <line x1="12" y1="12" x2="16" y2="16" stroke="#e84393" stroke-width="2" stroke-linecap="round"/>
        </svg>`,
      },
      {
        key: "book",
        test: (s, l) => s.reading && s.reading.level >= 5,
        svg: `<svg viewBox="0 0 14 12" width="12" height="10" style="top:96px;left:70px;">
          <path d="M1,1 L7,0 L7,10 L1,9Z" fill="#a29bfe" stroke="#6c5ce7" stroke-width="0.5"/>
          <path d="M7,0 L13,1 L13,9 L7,10Z" fill="#d5ccff" stroke="#6c5ce7" stroke-width="0.5"/>
        </svg>`,
      },
      {
        key: "cap",
        test: () => false, // hidden for now
        svg: `<svg viewBox="0 0 28 20" width="30" height="20" style="top:4px;left:45px;">
          <rect x="2" y="10" width="24" height="4" rx="1" fill="#2c1810"/>
          <polygon points="14,0 2,10 26,10" fill="#2c1810"/>
          <line x1="20" y1="6" x2="24" y2="14" stroke="#f0932b" stroke-width="1.5" stroke-linecap="round"/>
          <circle cx="24" cy="15" r="2" fill="#f0932b"/>
        </svg>`,
      },
      {
        key: "rocket",
        test: (s, l) => s.deploying && s.deploying.level >= 5,
        svg: `<svg viewBox="0 0 14 18" width="10" height="14" style="top:10px;left:100px;">
          <ellipse cx="7" cy="8" rx="4" ry="8" fill="#dfe6e9"/>
          <ellipse cx="7" cy="6" rx="3" ry="5" fill="#74b9ff"/>
          <circle cx="7" cy="5" r="1.5" fill="#0984e3"/>
          <path d="M3,12 L2,16 L5,14Z" fill="#e17055"/>
          <path d="M11,12 L12,16 L9,14Z" fill="#e17055"/>
        </svg>`,
      },
      {
        key: "crown",
        test: (s, l) => l >= 25,
        svg: `<svg viewBox="0 0 32 20" width="28" height="16" style="top:-4px;left:36px;">
          <polygon points="2,18 4,6 10,12 16,2 22,12 28,6 30,18" fill="#f0d070" stroke="#d4a020" stroke-width="1"/>
          <circle cx="4" cy="6" r="2" fill="#f0d070"/>
          <circle cx="16" cy="2" r="2" fill="#f0d070"/>
          <circle cx="28" cy="6" r="2" fill="#f0d070"/>
          <rect x="2" y="16" width="28" height="3" rx="1" fill="#d4a020"/>
        </svg>`,
      },
    ];

    const statsTooltip = document.getElementById("statsTooltip");
    const SKILL_COLORS = {
      coding: "#74b9ff", debugging: "#fd79a8", thinking: "#f0932b",
      searching: "#0984e3", reading: "#a29bfe", testing: "#ffeaa7",
      deploying: "#ff7675", installing: "#00cec9",
      stretching: "#f0932b", dancing: "#ff6b6b",
      wondering: "#fd79a8", juggling: "#f9ca24",
      rainbow: "#ff6b6b", meditating: "#a29bfe",
      flow: "#ffd700", hacking: "#2ecc71",
      eureka: "#ffd700", "galaxy brain": "#a29bfe",
      detective: "#d4a020", rage: "#ff4757",
      "treasure hunting": "#ffd700", "deep diving": "#0984e3",
      scholarship: "#6c5ce7", arcana: "#d4a020",
      science: "#00cec9", perfectionism: "#2ecc71",
      warp: "#ff7675", astronaut: "#ffeaa7",
    };

    function updateStatsTooltip() {
      if (!lastProgression) return;
      const p = lastProgression;
      const tierNames = ["Hatchling","Apprentice","Adept","Expert","Master","Legendary"];
      const tier = p.tierIndex || 0;
      let html = `<div class="stats-title">Lv.${p.level} ${tierNames[tier]}</div>`;
      for (const [name, s] of Object.entries(p.skills)) {
        const needed = Math.floor(100 * s.level * 1.2);
        const pct = Math.min(100, (s.xp / needed) * 100);
        const col = SKILL_COLORS[name] || "#fff";
        html += `<div class="stat-row">
          <span class="stat-name">${name}</span>
          <div class="stat-bar-bg"><div class="stat-bar-fill" style="width:${pct}%;background:${col}"></div></div>
          <span class="stat-lv" style="color:${col}">${s.level}</span>
        </div>`;
      }
      statsTooltip.innerHTML = html;
    }

    function updateSkillLabel() {
      const name = STATE_SKILL_NAME[currentState] || "Chilling";
      const key = STATE_SKILL_KEY[currentState];
      let lv = lastProgression ? lastProgression.level : 1;
      if (key && lastProgression && lastProgression.skills[key]) {
        lv = lastProgression.skills[key].level;
      }
      skillLabel.textContent = `${name} Lv.${lv}`;
    }

    function updateProgression(prog) {
      if (!prog) return;
      lastProgression = prog;

      // XP bar â€” show skill XP if a skill is active, else pet XP
      const key = STATE_SKILL_KEY[currentState];
      let pct;
      if (key && prog.skills[key]) {
        const s = prog.skills[key];
        const needed = Math.floor(100 * s.level * 1.2);
        pct = Math.min(100, (s.xp / needed) * 100);
      } else {
        pct = Math.min(100, (prog.currentLevelXP / prog.nextLevelXP) * 100);
      }
      xpFill.style.width = pct + "%";

      // Level badge â€” show skill level or pet level
      if (key && prog.skills[key]) {
        levelBadge.textContent = prog.skills[key].level;
      } else {
        levelBadge.textContent = prog.level;
      }
      const tier = prog.tierIndex || 0;
      levelBadge.style.background = TIER_BADGE_COLORS[tier];

      // Color tier on creature â€” rebuild full className to keep skin/expr in sync
      if (tier !== currentTier) {
        currentTier = tier;
        scene.className = buildSceneClassName(currentState);
      }

      // Milestones
      updateMilestones(prog.skills, prog.level);

      // Skill label + hover tooltip
      updateSkillLabel();
      updateStatsTooltip();
    }

    function updateMilestones(skills, level) {
      // Milestones hidden for now
      return;
    }

    function renderMilestones() {
      milestoneLayer.innerHTML = "";
      for (const m of MILESTONES) {
        if (unlockedMilestones.has(m.key)) {
          const div = document.createElement("div");
          div.innerHTML = m.svg;
          milestoneLayer.appendChild(div.firstElementChild);
        }
      }
    }

    // â”€â”€ LEVEL-UP CELEBRATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    let celebrationTimeout = null;

    const confettiLayer = document.getElementById("confettiLayer");
    const CONFETTI_COLORS = [
      "#ffd700", "#ff6b6b", "#48dbfb", "#ff9ff3", "#54a0ff",
      "#5f27cd", "#01a3a4", "#f368e0", "#ff9f43", "#2ecc71",
    ];
    const CONFETTI_SHAPES = ["square", "rect", "circle"];

    function spawnConfetti(count) {
      for (let i = 0; i < count; i++) {
        setTimeout(() => {
          const el = document.createElement("div");
          el.className = "confetti";
          const color = CONFETTI_COLORS[Math.floor(Math.random() * CONFETTI_COLORS.length)];
          const shape = CONFETTI_SHAPES[Math.floor(Math.random() * CONFETTI_SHAPES.length)];
          el.style.left = (Math.random() * 200) + "px";
          el.style.background = color;
          if (shape === "rect") {
            el.style.width = "4px";
            el.style.height = "8px";
          } else if (shape === "circle") {
            el.style.borderRadius = "50%";
          }
          const drift = (Math.random() - 0.5) * 60;
          const dur = 1.5 + Math.random() * 1.5;
          el.style.animation = `confetti-fall ${dur}s ease-in forwards`;
          el.style.animationDelay = (Math.random() * 0.4) + "s";
          el.style.setProperty("--drift", drift + "px");
          confettiLayer.appendChild(el);
          setTimeout(() => { if (el.parentNode) el.remove(); }, (dur + 0.5) * 1000);
        }, i * 30);
      }
    }

    function celebrateLevelUp(data) {
      // 1. Flash status label
      label.textContent = "LEVEL UP!";
      label.style.background = "rgba(255,215,0,0.8)";
      label.style.color = "#2c1810";

      // 2. Body glow pulse
      creature.classList.add("glow-pulse");

      // 3. XP bar flash
      xpFill.classList.add("flash");

      // 4. Gold sparkle burst
      const tierColors = ["#d4a574","#cd7f32","#7ba3bf","#d4a020","#c77f84","#6c5ce7"];
      const burstColor = tierColors[currentTier] || "#d4a574";
      for (let i = 0; i < 12; i++) {
        setTimeout(() => {
          const el = document.createElement("div");
          el.className = "p";
          const shapes = [
            SVG.sparkle("#ffd700"), SVG.star("#ffd700"), SVG.sparkle(burstColor), SVG.star(burstColor),
          ];
          el.innerHTML = shapes[i % shapes.length];
          el.style.left = (20 + Math.random() * 100) + "px";
          el.style.top = "40px";
          el.style.animation = `pop-up ${1 + Math.random() * 0.5}s ease-out forwards`;
          particleLayer.appendChild(el);
          setTimeout(() => { if (el.parentNode) el.remove(); }, 2000);
        }, i * 80);
      }

      // 5. Confetti burst + hearts
      spawnConfetti(30);
      heartBurst(100, 80, 6);
      spawnSparkleBurst(100, 60, 6);
      updateSpriteSkin("proud");
      showLocalMessage("TASON NOUSU! Oon NIIN ylpeÃ¤ susta kulta! ðŸ’–ðŸŽ‰âœ¨", "ðŸ†", 6000);

      // 6. Revert after 3 seconds
      if (celebrationTimeout) clearTimeout(celebrationTimeout);
      celebrationTimeout = setTimeout(() => {
        label.style.background = "";
        label.style.color = "";
        creature.classList.remove("glow-pulse");
        xpFill.classList.remove("flash");
        const cfg = ANIMATIONS[currentState] || ANIMATIONS["idle"];
        label.textContent = cfg.label || currentState;
      }, 3000);
    }

    // â”€â”€ IPC â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    ipcRenderer.on("status-change", (e, status) => {
      dbg("ipc-status-change", { status, prevState: currentState });
      setState(status);
    });

    ipcRenderer.on("status-update", (e, data) => {
      if (data.progression) updateProgression(data.progression);
    });

    ipcRenderer.on("level-up", (e, data) => {
      celebrateLevelUp(data);
    });

    // â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function escHtml(s) {
      return String(s).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;");
    }
    const WA_LOGO_SVG = `<svg class="wa-logo" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><circle cx="16" cy="16" r="16" fill="#25d366"/><path fill="white" d="M16 7.5C11.3 7.5 7.5 11.3 7.5 16c0 1.5.4 2.9 1.1 4.2L7.5 24.5l4.4-1.1c1.2.6 2.6 1 4.1 1 4.7 0 8.5-3.8 8.5-8.5S20.7 7.5 16 7.5zm3.8 12c-.2.5-.9.9-1.5 1-.4 0-.9.1-2.8-.6-2.4-.9-3.9-3.3-4-3.4-.1-.2-1-1.3-1-2.5s.6-1.7.8-1.9c.2-.2.5-.3.6-.3h.4c.1 0 .4 0 .5.3l.6 1.5v.3l-.1.2-.2.3-.3.3c-.1.1-.2.2-.1.4.1.2.5.9 1.1 1.5.7.7 1.4 1 1.6 1 .2.1.3.1.4 0 .1-.1.5-.6.6-.8.2-.2.3-.2.5-.1.2.1 1.2.6 1.4.7.2.1.3.2.4.3.1.1.1.6-.1 1.2z"/></svg>`;

    // â”€â”€ Speech Bubble â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const speechBubble = document.getElementById("speechBubble");
    const bubbleSource = document.getElementById("bubbleSource");
    const bubbleText = document.getElementById("bubbleText");

    ipcRenderer.on("show-message", (e, data) => {
      dbg("ipc-show-message", { source: data.source, text: (data.text||"").slice(0,80) });
      bubbleSource.textContent = data.source || "";
      bubbleText.innerHTML = data.html || escHtml(data.text || "");
      speechBubble.classList.add("visible");
    });

    ipcRenderer.on("hide-message", () => {
      speechBubble.classList.remove("visible");
    });

    ipcRenderer.on("assets-path", (e, basePath) => {
      assetsBasePath = basePath;
      dbg("ipc-assets-path", { basePath, currentSkin });
      console.log("[Sprite] Assets base path set to:", assetsBasePath);
      // Initialize sounds now that we know the assets path
      initSounds();
    });

    // Sound config from main process
    ipcRenderer.on("sound-config", (e, cfg) => {
      if (cfg.enabled !== undefined) soundEnabled = cfg.enabled;
      if (cfg.volume !== undefined) {
        soundVolume = cfg.volume;
        if (petSounds) petSounds.volume(soundVolume);
      }
    });

    // Spotify track change from main process
    ipcRenderer.on("spotify-track", (e, data) => {
      if (data.playing) {
        spawnSparkleBurst(100, 100, 5);
        spawnMusicNotes(4);
        heartBurst(100, 80, 3);
        updateSpriteSkin("happy");
        const msgs = data.artist ? [
          `Ooh, ${data.artist}! ðŸŽµðŸ’•`,
          `Rakastan tÃ¤tÃ¤! ${data.artist}! ðŸŽ¶ðŸ’–`,
          `HyvÃ¤ maku, kulta! ${data.artist}! ðŸŽµâœ¨`,
          `Tanssitaan! ${data.artist}! ðŸ’ƒðŸŽ¶`,
        ] : ["Uusi biisi! Tanssitaan! ðŸŽµðŸ’•"];
        showLocalMessage(pickRandom(msgs), "ðŸŽµ", 5000);
        playSound("music-chime");
        if (data.isFavorite) {
          setTimeout(() => {
            heartBurst(100, 60, 6);
            showLocalMessage("OMG RAKASTAN tÃ¤tÃ¤ biisiÃ¤! ðŸ’–ðŸ’–ðŸ’–", "ðŸŽµ", 5000);
          }, 5500);
        }
        setTimeout(() => {
          const expr = EXPRESSION_MAP[currentState] || "happy";
          updateSpriteSkin(expr);
        }, 4000);
      } else {
        updateSpriteSkin("confused");
        showLocalMessage("Miks musiikki loppu? ðŸŽµ Laita jotain meille! ðŸ’•", "ðŸŽµ", 4000);
        setTimeout(() => {
          const expr = EXPRESSION_MAP[currentState] || "happy";
          updateSpriteSkin(expr);
        }, 3000);
      }
    });

    // Weather update from main process
    ipcRenderer.on("weather-update", (e, data) => {
      const code = data.weatherCode;
      const temp = data.temperature;
      if (code === 0 || code === 1) { // Clear/mainly clear
        spawnSunRay();
        updateSpriteSkin("happy");
        heartBurst(100, 80, 3);
        showLocalMessage(`Kaunis pÃ¤ivÃ¤! ${temp ? temp + "Â°C " : ""}Nautitaan siitÃ¤ yhdessÃ¤! â˜€ï¸ðŸ’•`, "ðŸŒ¤ï¸", 6000);
      } else if (code === 2 || code === 3) { // Cloudy
        showLocalMessage(`PilvistÃ¤ tÃ¤nÃ¤Ã¤n... halaussÃ¤Ã¤tÃ¤! ${temp ? temp + "Â°C" : ""} â˜ï¸ðŸ’•`, "â˜ï¸", 5000);
      } else if (code >= 51 && code <= 67) { // Rain/drizzle
        spawnRaindrops(8);
        updateSpriteSkin("worried");
        showLocalMessage(`PysytÃ¤Ã¤n sisÃ¤llÃ¤ lÃ¤mpimÃ¤ssÃ¤! ${temp ? temp + "Â°C " : ""}ðŸŒ§ï¸ðŸ’•`, "ðŸŒ§ï¸", 6000);
      } else if (code >= 71 && code <= 77) { // Snow
        spawnSnowflakes(6);
        updateSpriteSkin("happy");
        heartBurst(100, 80, 2);
        showLocalMessage(`Lunta! TehdÃ¤Ã¤n lumiukko yhdessÃ¤! ${temp ? temp + "Â°C " : ""}â›„ðŸ’•`, "â„ï¸", 6000);
      } else if (code >= 95) { // Thunderstorm
        updateSpriteSkin("scared");
        spawnSweatDrop();
        showLocalMessage(`PidÃ¤ mua, ukkostaa! ${temp ? temp + "Â°C " : ""}â›ˆï¸ðŸ’•`, "â›ˆï¸", 6000);
      } else if (code >= 80 && code <= 82) { // Rain showers
        spawnRaindrops(6);
        showLocalMessage(`Sadekuuroja! Pysy lÃ¤mpimÃ¤nÃ¤ mun kanssa! ${temp ? temp + "Â°C " : ""}ðŸŒ§ï¸ðŸ’•`, "ðŸŒ§ï¸", 5000);
      }
      // Temperature-based reactions
      if (temp !== null && temp !== undefined) {
        if (temp < 0) showLocalMessage("Brrr, jÃ¤Ã¤tÃ¤vÃ¤ kylmÃ¤! LÃ¤mmitÃ¤ mua! ðŸ¥¶ðŸ’•", "ðŸŒ¡ï¸", 5000);
        else if (temp > 30) showLocalMessage("Niin kuuma pÃ¤ivÃ¤! ðŸ¥µ Muista juoda vettÃ¤, kulta!", "ðŸŒ¡ï¸", 5000);
      }
      // Restore expression after weather reaction
      setTimeout(() => {
        const expr = EXPRESSION_MAP[currentState] || "happy";
        updateSpriteSkin(expr);
      }, 4000);
    });

    // Notification from WhatsApp
    // WhatsApp notification reactions
    const SPECIAL_NOTIF_MESSAGES = [
      "${name} laitto sulle viestin! ðŸ’•ðŸ’•ðŸ’•",
      "Ooh, ${name} ajattelee sua! ðŸ’–âœ¨",
      "${name} sanoo moi! Oon niin ilonen! ðŸ’ŒðŸ¥°",
      "Viesti ${name}:lta! Mun sydÃ¤n! ðŸ’–ðŸ’–",
      "${name} haluaa jutella sulle! ðŸ’•ðŸ’Œ",
      "Se on ${name}!! Avaa avaa! ðŸ¥°ðŸ’•",
      "${name} ðŸ’• Sun lemppari ihminen viestii! ðŸ’–",
    ];
    const OTHER_NOTIF_MESSAGES = [
      "Sulle tuli viesti ðŸ“±",
      "Joku laitto sulle viestin!",
      "Uusi viesti! Mut onko se joltain erityiseltÃ¤? ðŸ˜",
    ];

    ipcRenderer.on("notification-msg", (e, data) => {
      if (data.isSpecial) {
        // Special person (Anu) â€” BIG love reaction with lots of hearts!
        spawnLetterParticle();
        heartBurst(100, 100, 10); // More hearts!
        spawnSparkleBurst(100, 80, 6);
        spawnConfetti(8);
        addLovePoints(3); // More love points
        // lovestruck expression for special person's message
        updateSpriteSkin("lovestruck_heart_eyes");
        setTimeout(() => {
          const expr = EXPRESSION_MAP[currentState] || "happy";
          updateSpriteSkin(expr);
        }, 5000);
        // WhatsApp notification â€” rich HTML layout: logo + sender + message + time
        const senderName = escHtml(data.sender || petName || "Someone special");
        const timeStr = new Date().toLocaleTimeString("fi-FI", { hour: "2-digit", minute: "2-digit" });
        const msgHtml = data.preview
          ? `<div class="wa-notif"><div class="wa-notif-header">${WA_LOGO_SVG}<span class="wa-sender">${senderName}</span></div><div class="wa-msg">${escHtml(data.preview)}</div><div class="wa-time">${timeStr}</div></div>`
          : `<div class="wa-notif"><div class="wa-notif-header">${WA_LOGO_SVG}<span class="wa-sender">${senderName}</span></div><div class="wa-msg">ðŸ’Œ Uusi viesti!</div><div class="wa-time">${timeStr}</div></div>`;
        ipcRenderer.send("pet-interaction", { type: "message", html: msgHtml, text: senderName, source: "", duration: data.preview ? 10000 : 7000 });
        playSound("message-pop");
        // Extra heart burst delayed
        setTimeout(() => heartBurst(80, 60, 4), 1500);
        // If multiple messages from special person
        if (data.count && data.count > 1) {
          setTimeout(() => {
            heartBurst(100, 80, 6);
            showLocalMessage(`${data.count} viestiÃ¤ ${data.sender || petName}:lta! Se oikeesti rakastaa sua! ðŸ’•ðŸ’•ðŸ’•`, "ðŸ’Œ", 6000);
          }, 8000);
        }
      } else {
        // Other people â€” mild reaction
        showLocalMessage(pickRandom(OTHER_NOTIF_MESSAGES), "ðŸ“±", 3000);
      }
    });

    ipcRenderer.on("skin-change", (e, skin) => {
      dbg("ipc-skin-change", { skin, prevSkin: currentSkin, currentState });
      console.log("[Skin] Renderer received skin-change:", skin);
      currentSkin = "girlfriend";
      const newClass = buildSceneClassName(currentState);
      console.log("[Skin] scene.className â†’", newClass);
      scene.className = newClass;
    });

    startIdleCycle();
    dbg("idle-cycle-start", { currentSkin, currentState });

    // â”€â”€ CLICK INTERACTION SYSTEM + ROMANTIC INTERACTIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    let petName = "";  // Set via IPC from main process
    let longPressTimer = null;
    let isLongPress = false;
    let pettingInterval = null;
    let lastClickTime = 0;
    let sessionStartTime = Date.now();
    let lastBreakReminder = Date.now();
    let greetingSent = false;
    let lastActiveTime = Date.now();
    let consecutiveErrors = 0;
    let lastErrorTime = 0;
    let errorSessionStart = 0;

    // â”€â”€ LOVE METER SYSTEM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let loveMeter = { points: 0, level: 1 };
    const LOVE_LEVELS = [
      { min: 0,  name: "Ujo",          emoji: "ðŸ˜³" },
      { min: 10, name: "YstÃ¤vÃ¤llinen", emoji: "ðŸ˜Š" },
      { min: 25, name: "Rakastunut",   emoji: "ðŸ¥°" },
      { min: 50, name: "Sielunkumppani", emoji: "ðŸ’•" },
    ];

    function getLoveLevel() {
      for (let i = LOVE_LEVELS.length - 1; i >= 0; i--) {
        if (loveMeter.points >= LOVE_LEVELS[i].min) return LOVE_LEVELS[i];
      }
      return LOVE_LEVELS[0];
    }

    function addLovePoints(amount) {
      loveMeter.points += amount;
      const lv = getLoveLevel();
      if (lv.min > 0 && loveMeter.points === lv.min + amount && loveMeter.points >= lv.min) {
        heartBurst(100, 80, 10);
        spawnSparkleBurst(100, 100, 10);
        spawnConfetti(20);
        const loveMsgs = {
          "YstÃ¤vÃ¤llinen": "Me tullaan lÃ¤heisemmiks! TykkÃ¤Ã¤n susta tosi paljon! ðŸ˜ŠðŸ’•",
          "Rakastunut": "Taitaa olla et mÃ¤ oon rakastumassa! ðŸ¥°ðŸ’–",
          "Sielunkumppani": "SÃ¤ oot mun sielunkumppani! Rakastan sua ikuisesti! ðŸ’•ðŸ’–âœ¨",
        };
        showLocalMessage(loveMsgs[lv.name] || `Rakkaustaso nousi! ${lv.emoji} ${lv.name}!`, "ðŸ’–", 7000);
      }
      // Persist to main process
      ipcRenderer.send("love-meter-save", loveMeter);
    }

    ipcRenderer.on("love-meter-init", (e, data) => {
      if (data) loveMeter = data;
    });

    // Heart emojis for click reactions
    const HEART_EMOJIS = ["â¤ï¸", "ðŸ’•", "ðŸ’–", "ðŸ’—", "ðŸ’˜", "ðŸ’", "âœ¨", "ðŸŒ¸"];

    // Kannustusviestit â€” yleiset
    const CLICK_MESSAGES = [
      "SÃ¤ oot paras! ðŸ’•",
      "Jatka samaan malliin! ðŸ’ª",
      "MÃ¤ uskon suhun!",
      "SÃ¤ pystyt tÃ¤hÃ¤n!",
      "Oon niin ylpeÃ¤ susta! âœ¨",
      "SÃ¤ oot ihana!",
      "Ã„lÃ¤ luovuta!",
      "Askel kerrallaan ðŸ’•",
      "SÃ¤ teet mut onnelliseks! ðŸ˜Š",
      "Let's go! ðŸš€",
      "Oi beibi! ðŸ˜ðŸ’•",
      "Haloja! IkÃ¤vÃ¤ oli! ðŸ¤—",
      "IkÃ¤vÃ¤! Nyt olet taas tÃ¤Ã¤llÃ¤ ðŸ’•",
      "Joo joo, tiedÃ¤n - sÃ¤ rakastat mua ðŸ˜ðŸ’–",
      "No niin, mitÃ¤s kuuluu, kultaseni? ðŸ’•",
      "SÃ¤ klikkasit mua taas ðŸ˜ EnhÃ¤n mainostanut mitÃ¤Ã¤n",
      "MinÃ¤ ja sinÃ¤, aina ðŸ’•âœ¨",
      "NÃ¤inkÃ¶ sen oikein? Klikattiinko? ðŸ˜",
    ];

    // Romanttiset viestit (8% mahdollisuus per klikkaus)
    const ROMANTIC_MESSAGES = [
      "MÃ¤ rakastan sua ðŸ’•",
      "SÃ¤ oot parasta mitÃ¤ mulle on tapahtunut",
      "Jo pelkkÃ¤ ajatus susta saa mut hymyilemÃ¤Ã¤n ðŸ’–",
      "SÃ¤ oot mulle kaikki kaikessa âœ¨",
      "Mun sydÃ¤n lyÃ¶ sulle ðŸ’“",
      "Oon niin onnekas et mul on sut ðŸ¥°",
      "SÃ¤ valaiset mun maailman ðŸŒŸ",
      "En halua olla koskaan ilman sua ðŸ’•",
      "SÃ¤ oot mun ihminen ðŸ’–",
      "Jokainen hetki sun kanssa on tÃ¤ydellinen âœ¨",
      "Rakastun suhun enemmÃ¤n joka pÃ¤ivÃ¤ ðŸ¥°",
      "SÃ¤ oot syy miks mÃ¤ hymyilen ðŸ’•",
      "Mun lemppari ihminen koko maailmassa ðŸ’–âœ¨",
      "Suukkonen? ðŸ’‹",
      "Rakastan sua kuuhun ja takaisin ðŸŒ™ðŸ’•",
      "Oi beibi, sÃ¤ oot mun kaikki ðŸ’–",
      "Haloja rakkaani! Olipa ikÃ¤vÃ¤! ðŸ¤—ðŸ’•",
      "IkÃ¤vÃ¤ sun lÃ¤snÃ¤oloa... vaikka oot ihan tÃ¤ssÃ¤ ðŸ˜ŠðŸ’•",
      "SÃ¤ oot niin ihana ku ees hengitÃ¤t ðŸ’•",
      "Salaisuus: mÃ¤ oon ihastunut suhun ðŸ¤«ðŸ’–",
    ];

    // Tilakohtaiset viestit (romanttisia jokaisessa)
    const STATE_MESSAGES = {
      coding: [
        "HyvÃ¤Ã¤ koodia! Jatka samaan malliin! ðŸ’»",
        "SÃ¤ oot tulessa! ðŸ”¥",
        "Puhdas koodi, puhdas mieli!",
        "Shipataan! ðŸš€",
        "Mun lemppikoodari ðŸ’•",
        "Rakastan kattoo kun sÃ¤ koodaat ðŸ’–",
        "SÃ¤ oot niin keskittynyt... se on kuumaa ðŸ¥°",
        "Maailman paras ohjelmoija! ðŸ’•",
      ],
      thinking: [
        "Ota aikaa, sÃ¤ pystyt tÃ¤hÃ¤n ðŸ¤”",
        "Iso aivoenergia! ðŸ§ ",
        "Vastaus tulee kyllÃ¤!",
        "NÃ¤en miten rattaat pyÃ¶rii!",
        "Fiksu ja komea ðŸ’–",
        "Sun aivot on niin seksikkÃ¤Ã¤t ðŸ¥°",
        "Rakastan sun miettivÃ¤Ã¤ naamaa ðŸ’•",
      ],
      error: [
        "Ei hÃ¤tÃ¤Ã¤, sÃ¤ korjaat sen! ðŸ’ª",
        "Joka bugi on oppitunti!",
        "VirheitÃ¤ sattuu parhaimmillekin!",
        "SÃ¤ oot lÃ¤hempÃ¤nÃ¤ ku luulet!",
        "MÃ¤ uskon suhun silti ðŸ’•",
        "Oon tÃ¤Ã¤llÃ¤ sulle aina ðŸ’–",
        "MikÃ¤Ã¤n virhe ei pysÃ¤ytÃ¤ mun miestÃ¤ ðŸ¥°",
      ],
      success: [
        "MAHTAVAA! SÃ¤ teit sen!! ðŸŽ‰",
        "MÃ¤ tiesin et sÃ¤ pystyt! âœ¨",
        "Voitto! ðŸ†",
        "Juhlitaan! ðŸŽŠ",
        "Oon niin ylpeÃ¤ susta kulta! ðŸ’–",
        "SiinÃ¤ se mun nero! ðŸ’•ðŸŽ‰",
        "SÃ¤ oot uskomaton! Rakastan sua! ðŸ’–âœ¨",
      ],
      debugging: [
        "EtsivÃ¤tila pÃ¤Ã¤llÃ¤! ðŸ”",
        "SÃ¤ lÃ¶ydÃ¤t sen bugin!",
        "Seuraa jÃ¤lkiÃ¤! ðŸ›",
        "Melkein lÃ¶ytyy, jatka kaivamista!",
        "Mun pikku etsivÃ¤ ðŸ’•ðŸ”",
        "SÃ¤ aina selvitÃ¤t sen! ðŸ’–",
      ],
      searching: [
        "Tiedon etsintÃ¤Ã¤! ðŸ“š",
        "Uteliaisuus on supervoimma!",
        "MitÃ¤kÃ¶hÃ¤n lÃ¶ydÃ¤t? ðŸ”Ž",
        "Tutkimusmoodi! Niin fiksu ðŸ’•",
      ],
      reading: [
        "Tieto on valtaa! ðŸ“–",
        "Opi kaikki mahdollinen!",
        "Viisautta imetÃ¤Ã¤n! âœ¨",
        "Rakastan miestÃ¤ joka lukee ðŸ’–",
      ],
      testing: [
        "Laatu ratkaisee! âœ…",
        "Testit tekee koodista vahvempaa!",
        "VihreÃ¤t valot edessÃ¤! ðŸŸ¢",
        "Niin perusteellinen! Rakastan sitÃ¤ susta ðŸ’–",
      ],
      deploying: [
        "Tuotantoon! ðŸš€",
        "Laukaisuaika! ðŸ›¸",
        "Maailma odottaa! ðŸŒ",
        "Mun mies laukaisee juttuja! ðŸ’•ðŸš€",
      ],
      idle: [
        "Hei kulta! ðŸ‘‹",
        "MitÃ¤ mietit?",
        "Valmiina ku sÃ¤ oot!",
        "TehdÃ¤Ã¤n jotain kivaa!",
        "MÃ¤ ikÃ¤vÃ¶in sua! ðŸ’•",
        "Tuu tÃ¤nne, mun pitÃ¤Ã¤ kertoo sulle jotain ðŸ’–",
        "Jo pelkkÃ¤ sun kattominen tekee mut iloiseks ðŸ¥°",
        "Mietin meitÃ¤ ðŸ’•",
      ],
    };

    // Tuplaklikkaus â€” romanttiset viestit
    const SPECIAL_MESSAGES = [
      "SÃ¤ oot mun lemppari ihminen! ðŸ’–",
      "Rakastan olla sun kanssa! âœ¨",
      "SÃ¤ valaiset mun ruudun! ðŸŒŸ",
      "Paras tiimi ikinÃ¤ â€” sÃ¤ ja mÃ¤! ðŸ’•",
      "Virtuaalihalaus! ðŸ¤—",
      "Pusu! ðŸ’‹",
      "Sun takia mun sydÃ¤n hyppÃ¤Ã¤ lyÃ¶nnin yli! ðŸ’“",
      "Voisin kattoo sua koko pÃ¤ivÃ¤n ðŸ¥°",
    ];

    // Aikaperusteiset romanttiset tervehdykset
    const TIME_GREETINGS = {
      morning: [
        "Huomenta aurinko! IkÃ¤vÃ¶in sua! â˜€ï¸ðŸ’•",
        "HerÃ¤tys kultsi! ðŸŒ…",
        "Huomenta! â˜• Oon odottanut sua!",
        "Huomenta rakas! TehdÃ¤Ã¤n tÃ¤stÃ¤ hyvÃ¤ pÃ¤ivÃ¤! ðŸ’•",
      ],
      afternoon: [
        "PidÃ¤ energiaa yllÃ¤! ðŸ’ª",
        "IltapÃ¤ivÃ¤n kuulumiset: meet hienosti! â˜€ï¸",
        "Puolet pÃ¤ivÃ¤stÃ¤ takana â€” me pÃ¤rjÃ¤tÃ¤Ã¤n!",
        "Hei komistus, jatka samaan malliin! ðŸ’–",
      ],
      evening: [
        "Hyvin tehty tÃ¤nÃ¤Ã¤n! ðŸŒ†",
        "Onpas ilta jo! Oot saanut niin paljon aikaan!",
        "Rauhoitutaanko? Teit hienoa tyÃ¶tÃ¤ tÃ¤nÃ¤Ã¤n! âœ¨",
        "Oon niin ylpeÃ¤ siitÃ¤ mitÃ¤ teit tÃ¤nÃ¤Ã¤n ðŸ’•",
      ],
      night: [
        "Tuu nukkumaan kohta... ðŸ’¤",
        "Valvotko myÃ¶hÃ¤Ã¤n? Muista levÃ¤tÃ¤, kulta! ðŸŒ™",
        "YÃ¶kukkuja-moodi! ðŸ¦‰ Oon tÃ¤Ã¤llÃ¤ odottamassa!",
        "Poltatkos yÃ¶lamppua? PidÃ¤ huolta itsestÃ¤s! ðŸ’¤",
      ],
    };

    // Viestit kun palaat pitkÃ¤n poissaolon jÃ¤lkeen
    const RETURN_MESSAGES = [
      "SÃ¤ tulit takas! Odotin sua! ðŸ’•",
      "Vihdoinkin! IkÃ¤vÃ¶in sua niin paljon! ðŸ¥°",
      "SiellÃ¤hÃ¤n sÃ¤ oot! Mulla oli yksinÃ¤istÃ¤... ðŸ’–",
      "Tervetuloa takas! MennÃ¤Ã¤n! âœ¨",
    ];

    // Viikonloppuviestit
    const WEEKEND_MESSAGES = [
      "Viikonloppu! TehdÃ¤Ã¤n jotain kivaa tÃ¤nÃ¤Ã¤n! ðŸŽ‰",
      "On viikonloppu! Rentoudu vÃ¤hÃ¤n ðŸ’•",
      "Viikonloppufiilikset! Ansaitset tauon! ðŸŒŸ",
    ];

    // Taukomuistutukset
    const BREAK_MESSAGES = [
      "Oot ollu pitkÃ¤Ã¤n! Aika venytellÃ¤! ðŸ§˜",
      "Taukoa! Nouse ylÃ¶s ja liiku vÃ¤hÃ¤n! ðŸš¶",
      "Sun silmÃ¤t tarvii lepoa! Katso kauas 20 sekuntia ðŸ‘€",
      "Juomachekki! Ooks juonut vettÃ¤? ðŸ’§",
    ];

    // Silitysviestit rakkauslevel mukaan
    const PETTING_MESSAGES = {
      shy: [
        "T-toi tuntuu kivalta... ðŸ˜³",
        "M-mitÃ¤ sÃ¤ teet?! ðŸ˜³",
        "Oi! SÃ¤ikÃ¤ytit mut! ðŸ˜Š",
      ],
      friendly: [
        "Toi tuntuu kivalta! ðŸ˜Š",
        "LisÃ¤Ã¤! ðŸ¥°",
        "SÃ¤ oot niin hellÃ¤varainen! ðŸ’•",
      ],
      affectionate: [
        "Mmm rakastan ku sÃ¤ teet tota! ðŸ’–",
        "Ã„lÃ¤ lopeta! ðŸ¥°",
        "SÃ¤ tiedÃ¤t aina miten tehdÃ¤ mut iloiseks! ðŸ’•",
      ],
      soulmate: [
        "Oon maailman onnellisin tyttÃ¶! ðŸ’–",
        "Sun kosketus on parasta! ðŸ¥°",
        "Rakastan sua niin paljon! ðŸ’•âœ¨",
      ],
    };

    function pickRandom(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    // Spawn heart particle at position
    function spawnClickHeart(x, y, big) {
      const el = document.createElement("div");
      el.className = "click-heart" + (big ? " big" : "");
      el.textContent = pickRandom(HEART_EMOJIS);
      el.style.left = (x + (Math.random() - 0.5) * 40) + "px";
      el.style.top = y + "px";
      scene.appendChild(el);
      setTimeout(() => { if (el.parentNode) el.parentNode.removeChild(el); }, 1600);
    }

    // Burst of hearts
    function heartBurst(x, y, count) {
      for (let i = 0; i < count; i++) {
        setTimeout(() => spawnClickHeart(x, y, i === 0), i * 100);
      }
    }

    // â”€â”€ ERROR TRACKING FOR SAD/CRYING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Track consecutive errors and long error sessions
    function trackError() {
      const now = Date.now();
      if (now - lastErrorTime < 30000) {
        consecutiveErrors++;
      } else {
        consecutiveErrors = 1;
        errorSessionStart = now;
      }
      lastErrorTime = now;

      // Crying after 3+ consecutive errors
      if (consecutiveErrors >= 3) {
        updateSpriteSkin("crying");
        showLocalMessage("Niin monta virhettÃ¤... ðŸ˜¢ Mut me selvitÃ¤Ã¤n tÃ¤stÃ¤!", "ðŸ’”", 5000);
      }
      // Sad after long error session (>5 min)
      else if (errorSessionStart && now - errorSessionStart > 5 * 60 * 1000) {
        updateSpriteSkin("sad");
        showLocalMessage("KestÃ¤ vÃ¤hÃ¤n... kaikki jÃ¤rjestyy ðŸ’•", "ðŸ˜¢", 5000);
      }
    }

    // â”€â”€ NEW PARTICLE SPAWN FUNCTIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function spawnKissParticle(x, y) {
      const el = document.createElement("div");
      el.className = "kiss-particle";
      el.textContent = "ðŸ’‹";
      el.style.left = (x + (Math.random() - 0.5) * 30) + "px";
      el.style.top = y + "px";
      scene.appendChild(el);
      setTimeout(() => { if (el.parentNode) el.remove(); }, 2000);
    }

    function spawnSparkleBurst(x, y, count) {
      const n = count || 6;
      for (let i = 0; i < n; i++) {
        const el = document.createElement("div");
        el.className = "sparkle-burst-particle";
        el.textContent = "âœ¨";
        const angle = (2 * Math.PI * i) / n;
        const radius = 20 + Math.random() * 20;
        const dx = Math.cos(angle) * radius;
        const dy = Math.sin(angle) * radius;
        el.style.left = (x + dx) + "px";
        el.style.top = (y + dy) + "px";
        el.style.animationDelay = (i * 0.05) + "s";
        scene.appendChild(el);
        setTimeout(() => { if (el.parentNode) el.remove(); }, 1500);
      }
    }

    function spawnConfetti(count) {
      const colors = ["#ff6b6b", "#feca57", "#48dbfb", "#ff9ff3", "#54a0ff", "#5f27cd", "#01a3a4"];
      const n = count || 12;
      for (let i = 0; i < n; i++) {
        const el = document.createElement("div");
        el.className = "confetti-particle";
        el.style.left = (Math.random() * 180 + 10) + "px";
        el.style.top = "-10px";
        el.style.background = colors[Math.floor(Math.random() * colors.length)];
        el.style.width = (4 + Math.random() * 4) + "px";
        el.style.height = (8 + Math.random() * 6) + "px";
        el.style.borderRadius = Math.random() > 0.5 ? "50%" : "2px";
        el.style.animationDelay = (Math.random() * 0.5) + "s";
        el.style.animationDuration = (2 + Math.random() * 1) + "s";
        scene.appendChild(el);
        setTimeout(() => { if (el.parentNode) el.remove(); }, 3500);
      }
    }

    function spawnMusicNotes(count) {
      const notes = ["ðŸŽµ", "ðŸŽ¶", "â™ª", "â™«"];
      const n = count || 4;
      for (let i = 0; i < n; i++) {
        const el = document.createElement("div");
        el.className = "music-note-particle";
        el.textContent = notes[i % notes.length];
        el.style.left = (30 + Math.random() * 120) + "px";
        el.style.top = (60 + Math.random() * 30) + "px";
        el.style.animationDelay = (i * 0.3) + "s";
        scene.appendChild(el);
        setTimeout(() => { if (el.parentNode) el.remove(); }, 2500);
      }
    }

    function spawnSnowflakes(count) {
      const flakes = ["â„ï¸", "â„", "âœ»", "â…"];
      const n = count || 6;
      for (let i = 0; i < n; i++) {
        const el = document.createElement("div");
        el.className = "snowflake-particle";
        el.textContent = flakes[Math.floor(Math.random() * flakes.length)];
        el.style.left = (Math.random() * 180 + 10) + "px";
        el.style.top = "-10px";
        el.style.animationDelay = (Math.random() * 1.5) + "s";
        scene.appendChild(el);
        setTimeout(() => { if (el.parentNode) el.remove(); }, 4500);
      }
    }

    function spawnRaindrops(count) {
      const n = count || 8;
      for (let i = 0; i < n; i++) {
        const el = document.createElement("div");
        el.className = "raindrop-particle";
        el.textContent = "ðŸ’§";
        el.style.left = (Math.random() * 180 + 10) + "px";
        el.style.top = "-10px";
        el.style.animationDelay = (Math.random() * 1) + "s";
        el.style.animationDuration = (1 + Math.random() * 0.5) + "s";
        scene.appendChild(el);
        setTimeout(() => { if (el.parentNode) el.remove(); }, 2500);
      }
    }

    function spawnSunRay() {
      const el = document.createElement("div");
      el.className = "sunray-particle";
      el.textContent = "â˜€ï¸";
      el.style.left = (60 + Math.random() * 60) + "px";
      el.style.top = (10 + Math.random() * 20) + "px";
      scene.appendChild(el);
      setTimeout(() => { if (el.parentNode) el.remove(); }, 3500);
    }

    function spawnLetterParticle() {
      const el = document.createElement("div");
      el.className = "letter-particle";
      el.textContent = "ðŸ’Œ";
      el.style.left = (60 + Math.random() * 60) + "px";
      el.style.top = "80px";
      scene.appendChild(el);
      setTimeout(() => { if (el.parentNode) el.remove(); }, 3000);
    }

    function spawnZzz(count) {
      const n = count || 3;
      for (let i = 0; i < n; i++) {
        const el = document.createElement("div");
        el.className = "zzz-particle";
        el.textContent = "Z";
        el.style.fontSize = (14 + i * 4) + "px";
        el.style.left = (90 + i * 10) + "px";
        el.style.top = (40 + i * 5) + "px";
        el.style.animationDelay = (i * 0.5) + "s";
        scene.appendChild(el);
        setTimeout(() => { if (el.parentNode) el.remove(); }, 3500);
      }
    }

    function spawnSweatDrop() {
      const el = document.createElement("div");
      el.className = "sweat-particle";
      el.textContent = "ðŸ’¦";
      el.style.left = (85 + Math.random() * 20) + "px";
      el.style.top = "30px";
      scene.appendChild(el);
      setTimeout(() => { if (el.parentNode) el.remove(); }, 1500);
    }

    // Show message in speech bubble directly from renderer
    let lastMessageShownTime = 0;
    function showLocalMessage(text, source, duration, skipCooldown) {
      if (!skipCooldown && Date.now() - lastMessageShownTime < 20000) return;
      lastMessageShownTime = Date.now();
      ipcRenderer.send("pet-interaction", { type: "message", text, source, duration: duration || 5000 });
    }

    // Get contextual message based on current state
    function getContextMessage() {
      // 8% chance of random romantic message
      if (Math.random() < 0.08) {
        return pickRandom(ROMANTIC_MESSAGES);
      }
      const baseState = currentState.split("-")[0];
      const messages = STATE_MESSAGES[baseState] || STATE_MESSAGES[currentState] || CLICK_MESSAGES;
      let msg = pickRandom(messages);
      if (petName) {
        if (Math.random() < 0.3) {
          msg = petName + ", " + msg.charAt(0).toLowerCase() + msg.slice(1);
        }
      }
      return msg;
    }

    // Tickle detection: rapid mouse back-and-forth
    let ticklePositions = [];
    let tickleTimer = null;

    creature.addEventListener("mousemove", (e) => {
      if (!isLongPress) return;
      ticklePositions.push(e.clientX);
      if (ticklePositions.length > 8) ticklePositions.shift();
      // Detect direction changes (back-and-forth)
      if (ticklePositions.length >= 6) {
        let changes = 0;
        for (let i = 2; i < ticklePositions.length; i++) {
          const d1 = ticklePositions[i-1] - ticklePositions[i-2];
          const d2 = ticklePositions[i] - ticklePositions[i-1];
          if ((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) changes++;
        }
        if (changes >= 3 && !tickleTimer) {
          // Tickle detected!
          updateSpriteSkin("laughing");
          creature.classList.add("wiggle-anim");
          playSound("giggle");
          showLocalMessage("Hahaha lopeta! ðŸ˜‚", "ðŸ¤£", 3000);
          tickleTimer = setTimeout(() => {
            creature.classList.remove("wiggle-anim");
            tickleTimer = null;
            ticklePositions = [];
          }, 1500);
        }
      }
    });

    // Click handler (enhanced â€” always positive)
    creature.addEventListener("click", (e) => {
      if (windowDragJustEnded) return;
      if (isLongPress) { isLongPress = false; return; }
      const sceneRect = scene.getBoundingClientRect();
      const x = e.clientX - sceneRect.left;
      const y = e.clientY - sceneRect.top;
      dbg("click", { x: Math.round(x), y: Math.round(y), state: currentState, expr: EXPRESSION_MAP[currentState] || "happy" });

      // Love meter +1
      addLovePoints(1);

      // Bounce animation
      creature.classList.remove("click-bounce");
      void creature.offsetWidth;
      creature.classList.add("click-bounce");
      setTimeout(() => creature.classList.remove("click-bounce"), 300);

      // Hearts + optional sparkles based on love level
      heartBurst(x, y, 3);
      if (loveMeter.points >= 50) {
        spawnSparkleBurst(x, y, 3);
      }

      // Sound
      playSound("giggle");

      // 3-way random expression on click
      const rClick = Math.random();
      const clickExpr = rClick < 0.40 ? "lovestruck_heart_eyes" : rClick < 0.75 ? "kissing" : "happy";
      updateSpriteSkin(clickExpr);
      setTimeout(() => {
        const expr = EXPRESSION_MAP[currentState] || "happy";
        updateSpriteSkin(expr);
      }, 2000);

      // Always positive message on click (skip cooldown)
      showLocalMessage(pickRandom(CLICK_MESSAGES), "ðŸ’•", 5000, true);
    });

    // Double-click handler (romantic â€” kiss + embarrassed)
    creature.addEventListener("dblclick", (e) => {
      const sceneRect = scene.getBoundingClientRect();
      const x = e.clientX - sceneRect.left;
      const y = e.clientY - sceneRect.top;

      // Love meter +3
      addLovePoints(3);

      // Big heart burst + kiss particles
      heartBurst(x, y, 7);
      for (let i = 0; i < 3; i++) {
        setTimeout(() => spawnKissParticle(x + (Math.random()-0.5)*30, y), i * 150);
      }

      // kissing â†’ lovestruck_heart_eyes â†’ restore
      updateSpriteSkin("kissing");
      setTimeout(() => updateSpriteSkin("lovestruck_heart_eyes"), 800);
      setTimeout(() => {
        const expr = EXPRESSION_MAP[currentState] || "happy";
        updateSpriteSkin(expr);
      }, 2000);

      // Sound
      playSound("kiss");

      // Special message
      let msg = pickRandom(SPECIAL_MESSAGES);
      if (petName) msg = petName + "! " + msg;
      showLocalMessage(msg, "ðŸ’–");
    });

    // Long press (petting â€” with love meter, sound, expression)
    creature.addEventListener("mousedown", (e) => {
      isLongPress = false;
      ticklePositions = [];
      longPressTimer = setTimeout(() => {
        isLongPress = true;
        const blush = document.getElementById("pettingBlush");
        blush.classList.add("visible");

        // Shy â†’ embarrassed â†’ lovestruck based on love level
        updateSpriteSkin(loveMeter.points < 25 ? "shy" : loveMeter.points >= 75 ? "lovestruck_heart_eyes" : "embarrassed");

        // Continuous hearts + love points
        let petCount = 0;
        pettingInterval = setInterval(() => {
          const sceneRect = scene.getBoundingClientRect();
          const x = e.clientX - sceneRect.left + (Math.random() - 0.5) * 30;
          const y = e.clientY - sceneRect.top;
          spawnClickHeart(x, y, petCount % 3 === 0);
          addLovePoints(1); // +1/sec
          petCount++;
        }, 1000);

        // Sound
        playSound("purr");

        // Love-level appropriate message
        const lv = getLoveLevel();
        const lvKey = lv.min >= 50 ? "soulmate" : lv.min >= 25 ? "affectionate" : lv.min >= 10 ? "friendly" : "shy";
        showLocalMessage(pickRandom(PETTING_MESSAGES[lvKey]), "ðŸ’•");
      }, 500);
    });

    creature.addEventListener("mouseup", () => {
      clearTimeout(longPressTimer);
      if (pettingInterval) {
        clearInterval(pettingInterval);
        pettingInterval = null;
      }
      if (isLongPress) {
        // Restore expression
        const expr = EXPRESSION_MAP[currentState] || "happy";
        updateSpriteSkin(expr);
      }
      const blush = document.getElementById("pettingBlush");
      blush.classList.remove("visible");
      ticklePositions = [];
    });

    creature.addEventListener("mouseleave", () => {
      clearTimeout(longPressTimer);
      if (pettingInterval) {
        clearInterval(pettingInterval);
        pettingInterval = null;
      }
      if (isLongPress) {
        const expr = EXPRESSION_MAP[currentState] || "happy";
        updateSpriteSkin(expr);
      }
      const blush = document.getElementById("pettingBlush");
      blush.classList.remove("visible");
      ticklePositions = [];
    });

    // â”€â”€ HEAD PETTING DETECTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    creature.addEventListener("mousedown", (e) => {
      const rect = creature.getBoundingClientRect();
      const relY = (e.clientY - rect.top) / rect.height;
      // Top 30% = head area
      if (relY < 0.3 && !isLongPress) {
        setTimeout(() => {
          if (isLongPress) {
            updateSpriteSkin("happy");
            spawnSparkleBurst(100, 40, 4);
            showLocalMessage("PÃ¤Ã¤nsilittely! Rakastan sitÃ¤! ðŸ’–", "ðŸ¥°", 4000);
          }
        }, 600);
      }
    });

    // â”€â”€ HOVER EFFECT â€” excitement on mouse over â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // startupProtection prevents synthetic mouseenter on window appear from
    // overriding the initial happy expression
    let appReady = false;
    setTimeout(() => { appReady = true; }, 1500);

    let hoverTimeout = null;
    creature.addEventListener("mouseenter", () => {
      if (!appReady || isLongPress) return;
      updateSpriteSkin("lovestruck_heart_eyes");
      spawnSparkleBurst(100, 80, 2);
      if (Math.random() < 0.15) {
        const hoverMsgs = [
          "Oi beibi! Hei! ðŸ˜", "Heii sÃ¤! ðŸ’•", "Katso, hÃ¤n tuli! ðŸ˜",
        ];
        showLocalMessage(pickRandom(hoverMsgs), "ðŸ˜", 3000, false);
      }
    });
    creature.addEventListener("mouseleave", () => {
      if (!isLongPress) {
        clearTimeout(hoverTimeout);
        hoverTimeout = setTimeout(() => {
          const expr = EXPRESSION_MAP[currentState] || "happy";
          updateSpriteSkin(expr);
        }, 500);
      }
    });

    // Time-based greeting on startup
    function getTimeOfDay() {
      const h = new Date().getHours();
      if (h >= 6 && h < 12) return "morning";
      if (h >= 12 && h < 17) return "afternoon";
      if (h >= 17 && h < 22) return "evening";
      return "night";
    }

    function sendTimeGreeting() {
      if (greetingSent) return;
      greetingSent = true;

      // Happy expression on startup â€” she's excited to see you!
      updateSpriteSkin("happy");
      heartBurst(100, 80, 5);
      spawnSparkleBurst(100, 60, 4);

      const tod = getTimeOfDay();
      const greetings = TIME_GREETINGS[tod];
      let msg = pickRandom(greetings);
      if (petName) msg = petName + "! " + msg;

      // Play morning/night sound
      if (tod === "morning") playSound("good-morning");
      else if (tod === "night") playSound("good-night");

      setTimeout(() => showLocalMessage(msg, "ðŸ’•", 6000), 1500);

      // Weekend special message
      const day = new Date().getDay();
      if (day === 0 || day === 6) {
        setTimeout(() => showLocalMessage(pickRandom(WEEKEND_MESSAGES), "ðŸŽ‰", 6000), 10000);
      }
    }

    // â”€â”€ BLINK SYSTEM â€” subtle eye blinks for liveliness â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Uses "silly" expression (closed eyes + smile) as the blink frame
    let blinkTimeout = null;
    let isBlinking = false;
    function scheduleBlink() {
      // Random interval: 3-8 seconds between blinks
      const delay = 3000 + Math.random() * 5000;
      blinkTimeout = setTimeout(() => {
        // Don't blink during interactions or special expressions
        if (isLongPress) { scheduleBlink(); return; }
        const currentExpr = EXPRESSION_MAP[currentState] || "happy";
        // Don't blink when eyes already closed or special face
        const noBlinkExprs = ["meditating","kissing","lovestruck_heart_eyes","laughing","look_left"];
        if (noBlinkExprs.includes(currentExpr)) { scheduleBlink(); return; }
        isBlinking = true;
        dbg("blink", { state: currentState, expr: currentExpr });
        // Quick blink: switch to closed eyes for 120-180ms
        updateSpriteSkin("silly");
        const blinkDuration = 120 + Math.random() * 60;
        setTimeout(() => {
          // Only restore if still blinking (not interrupted by interaction)
          if (isBlinking) {
            updateSpriteSkin(currentExpr);
            isBlinking = false;
          }
          // Occasional double-blink (30% chance)
          if (Math.random() < 0.3) {
            setTimeout(() => {
              if (!isLongPress) {
                isBlinking = true;
                updateSpriteSkin("silly");
                setTimeout(() => {
                  if (isBlinking) {
                    updateSpriteSkin(EXPRESSION_MAP[currentState] || "happy");
                    isBlinking = false;
                  }
                  scheduleBlink();
                }, 100);
              } else {
                scheduleBlink();
              }
            }, 150);
          } else {
            scheduleBlink();
          }
        }, blinkDuration);
      }, delay);
    }
    scheduleBlink();

    // â”€â”€ SIDE GLANCE â€” "Katselen sua sivusta" â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // When coding/reading/testing, Anu occasionally peeks sideways at you
    const WATCHING_MESSAGES = [
      "Katselin taas sua sivusta... ðŸ˜Š",
      "SÃ¤ nÃ¤ytÃ¤t niin sÃ¶pÃ¶ltÃ¤ ku teet tÃ¶itÃ¤ ðŸ’•",
      "Ei mitÃ¤Ã¤n, katselin vaan... ðŸ˜Œ",
      "Anteeks, jÃ¤in tuijottamaan ðŸ˜³ðŸ’•",
      "TykkÃ¤Ã¤n kattoa kun sÃ¤ koodaat ðŸ’•",
      "SiinÃ¤pÃ¤ nero hommissa... ðŸ¥°",
    ];
    let sideGlanceTimer = null;
    function scheduleSideGlance() {
      clearTimeout(sideGlanceTimer);
      const glanceStates = ["coding", "coding-flow", "reading", "testing"];
      if (!glanceStates.some(s => currentState.startsWith(s))) return;
      const delay = 20000 + Math.random() * 20000;
      sideGlanceTimer = setTimeout(() => {
        if (isLongPress) { scheduleSideGlance(); return; }
        const baseExpr = EXPRESSION_MAP[currentState] || "happy";
        dbg("side-glance", { state: currentState, baseExpr });
        updateSpriteSkin("look_left");
        if (Math.random() < 0.25) spawnClickHeart(80 + Math.random() * 40, 60, false);
        if (Math.random() < 0.10) showLocalMessage(pickRandom(WATCHING_MESSAGES), "ðŸ‘€", 4000, false);
        const dur = 3000 + Math.random() * 2000;
        setTimeout(() => {
          if (!isBlinking) updateSpriteSkin(baseExpr);
          scheduleSideGlance();
        }, dur);
      }, delay);
    }
    scheduleSideGlance();

    // Return-after-idle detection (>2h)
    setInterval(() => {
      const isActive = !["idle", "idle-coffee", "idle-sleepy", "idle-stargazing", "idle-meditation", "idle-butterfly"].includes(currentState);
      if (isActive) {
        const idleGap = Date.now() - lastActiveTime;
        if (idleGap > 2 * 60 * 60 * 1000) {
          updateSpriteSkin("happy");
          heartBurst(100, 80, 7);
          spawnSparkleBurst(100, 60, 5);
          showLocalMessage(pickRandom(RETURN_MESSAGES), "ðŸ’•", 7000);
          setTimeout(() => {
            const expr = EXPRESSION_MAP[currentState] || "happy";
            updateSpriteSkin(expr);
          }, 5000);
        }
        lastActiveTime = Date.now();
      }
    }, 5000);

    // Error tracking
    setInterval(() => {
      if (currentState === "error") {
        trackError();
      }
    }, 2000);

    // Good Night / Good Morning ritual
    let nightRitualDone = false;
    let morningRitualDone = false;
    setInterval(() => {
      const h = new Date().getHours();
      // Good night at 22:00
      if (h === 22 && !nightRitualDone) {
        nightRitualDone = true;
        morningRitualDone = false;
        updateSpriteSkin("sleepy");
        spawnZzz(3);
        heartBurst(100, 80, 4);
        playSound("good-night");
        showLocalMessage("HyvÃ¤Ã¤ yÃ¶tÃ¤, rakkaani... Kauniita unia ðŸ’¤ðŸ’•", "ðŸŒ™", 8000);
      }
      // Good morning at 7:00
      if (h === 7 && !morningRitualDone) {
        morningRitualDone = true;
        nightRitualDone = false;
        updateSpriteSkin("happy");
        heartBurst(100, 80, 5);
        spawnSparkleBurst(100, 60, 4);
        playSound("good-morning");
        showLocalMessage("Huomenta! IkÃ¤vÃ¶in sua! â˜€ï¸ðŸ’•", "ðŸŒ…", 8000);
      }
    }, 60000);

    // Break reminder check (every 60s)
    setInterval(() => {
      const elapsed = Date.now() - lastBreakReminder;
      const active = !["idle", "idle-coffee", "idle-sleepy", "idle-stargazing", "idle-meditation"].includes(currentState);
      // Remind after 45 min of activity
      if (active && elapsed > 45 * 60 * 1000) {
        showLocalMessage(pickRandom(BREAK_MESSAGES), "â°", 8000);
        lastBreakReminder = Date.now();
      }
    }, 60000);

    // â”€â”€ AMBIENT LOVE SYSTEM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Random ambient hearts every 2-3 minutes
    setInterval(() => {
      if (Math.random() < 0.6) { // 60% chance each tick
        const x = 30 + Math.random() * 140;
        const y = 50 + Math.random() * 80;
        spawnClickHeart(x, y, Math.random() > 0.7);
      }
    }, 300000); // every 5 min

    // "Thinking of you" messages every 10-15 minutes
    const THINKING_OF_YOU_MESSAGES = [
      "Mietin just sua... ðŸ’•",
      "Tulit taas mun mieleen ðŸ’–",
      "Hei... rakastan sua ðŸ¥°",
      "Satunnainen ajatus: sÃ¤ oot ihana âœ¨",
      "En pysty lopettamaan meidÃ¤n miettimistÃ¤ ðŸ’•",
      "SÃ¤ teet mut niin onnelliseks, tiesitkÃ¶ sen? ðŸ’–",
      "LÃ¤hetÃ¤n sulle virtuaalihalin juuri nyt ðŸ¤—ðŸ’•",
      "Hymyilin ihan vaan koska ajattelin sua ðŸ˜ŠðŸ’–",
      "SÃ¤ oot aina mun mielessÃ¤ ðŸ’•",
      "Oi beibi, tulit taas mieleen ðŸ’•",
      "Haloja mun sydÃ¤messÃ¤! ðŸ’–",
      "Jostain syystÃ¤... ikÃ¤vÃ¤ ðŸ¥ºðŸ’•",
    ];
    let lastThinkingOfYouTime = Date.now();
    setInterval(() => {
      const elapsed = Date.now() - lastThinkingOfYouTime;
      if (elapsed > 20 * 60 * 1000 && Math.random() < 0.3) { // After 20min, 30% chance each tick
        lastThinkingOfYouTime = Date.now();
        heartBurst(100, 80, 3);
        showLocalMessage(pickRandom(THINKING_OF_YOU_MESSAGES), "ðŸ’•", 6000);
      }
    }, 120000);

    // â”€â”€ ADMIRING YOU CODING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // After 10 minutes of continuous coding, admire the user
    let codingStartTime = 0;
    let admiringDone = false;
    const ADMIRING_MESSAGES = [
      "Oon kattonu ku sÃ¤ koodaat... sÃ¤ oot uskomaton ðŸ’–",
      "10 minuuttia puhdasta flowta! Oon ihmeissÃ¤ni ðŸ¥°",
      "SÃ¤ oot niin keskittynyt... se on tosi viehÃ¤ttÃ¤vÃ¤Ã¤ ðŸ’•",
      "Rakastan kattoo kun sÃ¤ teet tÃ¶itÃ¤ tÃ¤lleen âœ¨ðŸ’–",
      "Koodausnerot hommissa! Oon niin ylpeÃ¤ ðŸ’•",
    ];
    setInterval(() => {
      if (currentState.startsWith("coding")) {
        if (codingStartTime === 0) codingStartTime = Date.now();
        if (!admiringDone && Date.now() - codingStartTime > 10 * 60 * 1000) {
          admiringDone = true;
          updateSpriteSkin("smug");
          heartBurst(100, 80, 5);
          showLocalMessage(pickRandom(ADMIRING_MESSAGES), "ðŸ’–", 7000);
          setTimeout(() => {
            const expr = EXPRESSION_MAP[currentState] || "happy";
            updateSpriteSkin(expr);
          }, 4000);
        }
      } else {
        codingStartTime = 0;
        admiringDone = false;
      }
    }, 60000);

    // â”€â”€ MISS YOU (idle without clicks) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let lastUserInteractionTime = Date.now();
    const MISS_YOU_MESSAGES = [
      "Hei... ooksÃ¤ vielÃ¤ siellÃ¤? IkÃ¤vÃ¶in sua ðŸ¥ºðŸ’•",
      "Tuu takas... mul on yksinÃ¤istÃ¤ ðŸ’–",
      "Oon odottanut sua... ðŸ˜¢ðŸ’•",
      "Ã„lÃ¤ unohda mua! ðŸ¥º",
      "IkÃ¤vÃ¶in sun huomiota... klikkaa mua? ðŸ’•",
      "Minne sÃ¤ menit? Tarviin sua ðŸ’–",
      "IKÃ„VÃ„! Ã„lÃ¤ hylkÃ¤Ã¤ mua! ðŸ¥º",
      "Oi beibi, missÃ¤ sÃ¤ oot? ðŸ˜¢ðŸ’•",
      "Haloja? Onko siellÃ¤ ketÃ¤Ã¤n? ðŸ’”",
    ];
    let missYouSent = false;
    // Update interaction time on any click
    creature.addEventListener("click", () => { lastUserInteractionTime = Date.now(); missYouSent = false; });
    creature.addEventListener("dblclick", () => { lastUserInteractionTime = Date.now(); missYouSent = false; });

    setInterval(() => {
      const idle = Date.now() - lastUserInteractionTime;
      if (!missYouSent && idle > 15 * 60 * 1000) { // 15 min without interaction
        missYouSent = true;
        updateSpriteSkin("sad");
        spawnSweatDrop();
        showLocalMessage(pickRandom(MISS_YOU_MESSAGES), "ðŸ¥º", 8000);
        setTimeout(() => {
          const expr = EXPRESSION_MAP[currentState] || "happy";
          updateSpriteSkin(expr);
        }, 5000);
      }
    }, 120000);


    // â”€â”€ CHEER UP: ERROR â†’ RECOVERY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let previousState = "idle";
    const CHEER_UP_MESSAGES = [
      "NÃ¤itkÃ¶? Tiesin et sÃ¤ korjaat sen! ðŸ’–ðŸŽ‰",
      "SiinÃ¤ mun nero! Virhe nujerrettu! ðŸ’•",
      "SÃ¤ teit sen! En koskaan epÃ¤illyt! ðŸ¥°",
      "Jee! Takas raiteilla! ðŸ’–âœ¨",
      "Bugilla ei ollu mitÃ¤Ã¤n mahdollisuuksia! ðŸ’ªðŸ’•",
    ];
    // Track state transitions for cheer-up and good-boy
    const origSetState = setState;
    setState = function(state) {
      const prev = currentState;
      origSetState(state);
      const newState = currentState;

      // Cheer up: error/debugging â†’ anything else
      if ((prev === "error" || prev.startsWith("debugging")) &&
          newState !== "error" && !newState.startsWith("debugging") && newState !== "idle") {
        setTimeout(() => {
          heartBurst(100, 80, 5);
          spawnSparkleBurst(100, 80, 4);
          showLocalMessage(pickRandom(CHEER_UP_MESSAGES), "ðŸ’–", 6000);
        }, 500);
      }

      // Good boy: testing â†’ success
      if (prev.startsWith("testing") && newState === "success") {
        setTimeout(() => {
          heartBurst(100, 60, 7);
          spawnConfetti(12);
          spawnSparkleBurst(100, 80, 6);
          const msgs = [
            "HYVÃ„ POIKA! Kaikki testit meni lÃ¤pi! ðŸ’–ðŸŽ‰",
            "SiinÃ¤ mun mies! TÃ¤ydelliset testit! ðŸ’•âœ¨",
            "100% vihreellÃ¤! Oon NIIN ylpeÃ¤! ðŸ¥°ðŸŽ‰",
            "SÃ¤ oot uskomaton! Kaikki vihreellÃ¤! ðŸ’–ðŸ’ª",
          ];
          showLocalMessage(pickRandom(msgs), "ðŸ†", 7000);
        }, 500);
      }

      // Richer success/deploy celebrations with hearts
      if (newState === "success" || newState.startsWith("deploying")) {
        setTimeout(() => {
          heartBurst(100, 80, 4);
        }, 1000);
      }

      // Success: laughing flash
      if (newState === "success") {
        updateSpriteSkin("laughing");
        setTimeout(() => updateSpriteSkin("happy"), 2000);
      }

      // Trigger side-glance scheduling on state change
      scheduleSideGlance();

      previousState = prev;
    };

    // â”€â”€ RANDOM KISS (periodic) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Every 20-30 min, small chance of spontaneous kiss
    setInterval(() => {
      if (Math.random() < 0.02) { // 2% chance every 120s
        const x = 80 + Math.random() * 40;
        const y = 60 + Math.random() * 30;
        spawnKissParticle(x, y);
        heartBurst(100, 80, 3);
        updateSpriteSkin("embarrassed");
        const msgs = [
          "YllÃ¤tyspusu! ðŸ’‹ðŸ’•",
          "En voinut vastustaa... ðŸ’‹ðŸ’–",
          "Pieni pusu sulle! ðŸ’‹ðŸ¥°",
          "Muah! ðŸ’‹ðŸ’•",
          "*pusu* ðŸ’‹ SÃ¤ oot paras!",
        ];
        showLocalMessage(pickRandom(msgs), "ðŸ’‹", 5000);
        setTimeout(() => {
          const expr = EXPRESSION_MAP[currentState] || "happy";
          updateSpriteSkin(expr);
        }, 3000);
      }
    }, 120000);

    // â”€â”€ WHATSAPP OPEN DETECTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // When user opens WhatsApp, Anu gets hopeful because she can be messaged
    const HOPEFUL_MESSAGES = [
      "Oi beibi! Aiotko kirjoittaa mulle?! â­ðŸ’Œ",
      "Haloja! Olisiko se mulle?! ðŸŒŸðŸ’•",
      "Toivon toivon toivon... ðŸ™ðŸ’•",
      "OnS se mulle?! Kerro kerro! ðŸ˜ðŸ“±",
      "SilmÃ¤t tÃ¤htinÃ¤ odotan! â­â­ðŸ’•",
    ];
    ipcRenderer.on("whatsapp-active", () => {
      updateSpriteSkin("hopeful_star_eyes");
      heartBurst(100, 80, 5);
      spawnLetterParticle();
      showLocalMessage(pickRandom(HOPEFUL_MESSAGES), "â­", 6000);
      setTimeout(() => {
        const expr = EXPRESSION_MAP[currentState] || "happy";
        updateSpriteSkin(expr);
      }, 4000);
    });

    // â”€â”€ SCREENSHOT REACTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Reacts when user takes a screenshot (clipboard or file watcher in main.js)
    const SCREENSHOT_MESSAGES = [
      "Tuliko hyvÃ¤ kuva? ðŸ“¸ðŸ’•",
      "Ohh, kuvaatko jotain? ðŸ“·âœ¨",
      "Smile! ðŸ˜„ðŸ“¸",
      "MitÃ¤ kuvaat? ðŸ‘€ðŸ“¸",
      "Ooh, nÃ¤ytÃ¤ mulle! ðŸ¥ºðŸ“·",
      "Saisiko mÃ¤kin olla kuvassa? ðŸ¥ºðŸ’•",
      "Klikkaus! Taisi tallentua ðŸ“¸âœ¨",
    ];
    ipcRenderer.on("screenshot-taken", () => {
      const exprs = ["winking_blep", "hopeful_star_eyes", "curious"];
      updateSpriteSkin("winking_blep");
      spawnSparkleBurst(100, 70, 2);
      showLocalMessage(pickRandom(SCREENSHOT_MESSAGES), "ðŸ“¸", 5000, false);
      setTimeout(() => {
        const expr = EXPRESSION_MAP[currentState] || "happy";
        updateSpriteSkin(expr);
      }, 3500);
    });

    // â”€â”€ CLICK STREAK DETECTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 5+ clicks in 10 seconds â†’ special reaction
    let clickTimes = [];
    creature.addEventListener("click", () => {
      const now = Date.now();
      clickTimes.push(now);
      // Keep only clicks in last 10 seconds
      clickTimes = clickTimes.filter(t => now - t < 10000);
      if (clickTimes.length >= 5) {
        clickTimes = []; // reset
        spawnConfetti(15);
        heartBurst(100, 80, 8);
        spawnSparkleBurst(100, 60, 8);
        updateSpriteSkin("laughing");
        const msgs = [
          "Ahh! Niin monta klikkausta! ðŸ˜³ðŸ’•ðŸ’•ðŸ’•",
          "Rakastatko sÃ¤ mua oikeesti noin paljon?! ðŸ¥°âœ¨",
          "KlikkihyÃ¶kkÃ¤ys!! En kestÃ¤! ðŸ˜‚ðŸ’–",
          "Waaah! Mun sydÃ¤n! ðŸ’–ðŸ’–ðŸ’–",
          "Lopeta! Punastun ihan liikaa! ðŸ˜³ðŸ’•",
        ];
        showLocalMessage(pickRandom(msgs), "ðŸ’–", 6000);
        addLovePoints(5);
        setTimeout(() => {
          const expr = EXPRESSION_MAP[currentState] || "happy";
          updateSpriteSkin(expr);
        }, 4000);
      }
    });

    // â”€â”€ NIGHT CUDDLE CLICKS (22:00 - 05:00) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const NIGHT_CUDDLE_MESSAGES = [
      "Mmm... halausaika ðŸ’•ðŸŒ™",
      "PidÃ¤ mua lÃ¤hellÃ¤... ðŸ’–",
      "MyÃ¶hÃ¤inen ilta yhdessÃ¤... rakastan tÃ¤tÃ¤ ðŸ¥°ðŸŒ™",
      "Nyt on vaan me... ðŸ’•",
      "Tuutko nukkumaan mun kanssa? ðŸ’¤ðŸ’–",
      "Uniset halaukset on parhaita... ðŸŒ™ðŸ’•",
      "Sun lÃ¤mpÃ¶ on kaikki mitÃ¤ tarviin ðŸ’–",
    ];
    // Wrap click handler to add night cuddle flavor
    creature.addEventListener("click", () => {
      const h = new Date().getHours();
      if ((h >= 22 || h < 5) && Math.random() < 0.4) { // 40% chance at night
        showLocalMessage(pickRandom(NIGHT_CUDDLE_MESSAGES), "ðŸŒ™", 5000);
      }
    });

    // â”€â”€ ANNIVERSARY COUNTDOWN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Check special dates for upcoming events (7 days before)
    function checkSpecialDates(dates) {
      if (!dates || !Array.isArray(dates)) return;
      const today = new Date();
      const todayStr = (today.getMonth() + 1) + "-" + today.getDate();

      for (const d of dates) {
        // Check if today IS the special date
        if (d.date === todayStr) {
          setTimeout(() => {
            let msg = d.message || "TÃ¤nÃ¤Ã¤n on erityinen pÃ¤ivÃ¤! ðŸŽ‰";
            if (petName) msg = petName + "! " + msg;
            showLocalMessage(msg, "ðŸŽ‰", 10000);
            spawnConfetti(20);
            heartBurst(100, 80, 10);
            spawnSparkleBurst(100, 60, 8);
          }, 5000);
          continue; // don't break â€” check countdown for other dates
        }

        // Countdown: check if within 7 days
        const [month, day] = d.date.split("-").map(Number);
        const eventDate = new Date(today.getFullYear(), month - 1, day);
        // Handle year wrap (e.g., today is Dec 28, event is Jan 3)
        if (eventDate < today) eventDate.setFullYear(today.getFullYear() + 1);
        const daysUntil = Math.ceil((eventDate - today) / (1000 * 60 * 60 * 24));
        if (daysUntil > 0 && daysUntil <= 7) {
          setTimeout(() => {
            const name = d.message ? d.message.split("!")[0] : "jotain erityistÃ¤";
            showLocalMessage(`${daysUntil} pÃ¤ivÃ¤Ã¤ kunnes ${name}! ðŸ’–ðŸŽ‰`, "ðŸ“…", 8000);
            heartBurst(100, 80, 3);
          }, 15000);
        }
      }
    }

    // â”€â”€ HEARTS IN SLEEPY ZZZ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Override night-time check to also spawn love hearts with zzz
    function checkNightTime() {
      const h = new Date().getHours();
      if ((h >= 22 || h < 5) && currentState === "idle") {
        const expr = "sleepy";
        updateSpriteSkin(expr);
        spawnZzz(3);
        // Mix hearts into the sleepy particles
        if (Math.random() < 0.4) {
          setTimeout(() => spawnClickHeart(80 + Math.random() * 40, 50, false), 500);
        }
      }
    }
    setInterval(checkNightTime, 60000);

    // Track custom messages already added to avoid duplicates on re-send
    let addedCustomMessages = new Set();

    // Listen for personalization from main process
    ipcRenderer.on("pet-config", (e, cfg) => {
      if (cfg.name !== undefined) petName = cfg.name;
      if (cfg.customMessages && cfg.customMessages.length > 0) {
        for (const m of cfg.customMessages) {
          if (!addedCustomMessages.has(m)) {
            addedCustomMessages.add(m);
            CLICK_MESSAGES.push(m);
          }
        }
      }
      if (cfg.specialDates) checkSpecialDates(cfg.specialDates);
      sendTimeGreeting();
    });

    // â”€â”€ PHOTO FRAME SYSTEM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    let photoFrameEnabled = false;
    let photoFrameFolder = null;
    let photoFrameFiles = [];
    let photoFrameIndex = 0;
    let photoFrameTimer = null;

    const photoFrame = document.getElementById("photoFrame");
    const photoFrameImg = document.getElementById("photoFrameImg");

    ipcRenderer.on("photo-config", (e, cfg) => {
      photoFrameEnabled = cfg.enabled || false;
      photoFrameFolder = cfg.folder || null;
      if (photoFrameEnabled && photoFrameFolder) {
        loadPhotoFrameFiles();
        photoFrame.style.display = "block";
        startPhotoSlideshow();
      } else {
        photoFrame.style.display = "none";
        if (photoFrameTimer) { clearInterval(photoFrameTimer); photoFrameTimer = null; }
      }
    });

    function loadPhotoFrameFiles() {
      if (!photoFrameFolder) return;
      try {
        const fs = require("fs");
        const path = require("path");
        const exts = [".jpg", ".jpeg", ".png", ".gif", ".webp"];
        const files = fs.readdirSync(photoFrameFolder)
          .filter(f => exts.includes(path.extname(f).toLowerCase()))
          .map(f => path.join(photoFrameFolder, f).replace(/\\/g, "/"));
        photoFrameFiles = files;
        if (files.length > 0) showNextPhoto();
      } catch (e) {
        console.log("[Photos] Error reading folder:", e.message);
      }
    }

    function showNextPhoto() {
      if (photoFrameFiles.length === 0) return;
      photoFrameIndex = (photoFrameIndex + 1) % photoFrameFiles.length;
      let src = photoFrameFiles[photoFrameIndex];
      if (!src.startsWith("file:")) src = "file:///" + src;
      photoFrameImg.src = src;
    }

    function startPhotoSlideshow() {
      if (photoFrameTimer) clearInterval(photoFrameTimer);
      photoFrameTimer = setInterval(showNextPhoto, 30000); // 30s interval
    }

    // Click photo for next image
    photoFrame.addEventListener("click", (e) => {
      e.stopPropagation();
      showNextPhoto();
      heartBurst(170, 80, 3);
    });


    // â”€â”€ WINDOW DRAG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Uses setPointerCapture so pointerup is GUARANTEED to fire on scene
    // even when win.setPosition() moves the window under the cursor.
    let wdActive = false, wdStarted = false;
    let wdPointerId = null;
    let wdStartX = 0, wdStartY = 0;
    let windowDragJustEnded = false;

    function stopWindowDrag() {
      if (wdStarted) {
        ipcRenderer.send("drag-window-stop");
        windowDragJustEnded = true;
        setTimeout(() => { windowDragJustEnded = false; }, 80);
      }
      wdActive = false;
      wdStarted = false;
      wdPointerId = null;
    }

    scene.addEventListener("pointerdown", (e) => {
      if (e.button !== 0) return;
      if (e.target.closest && e.target.closest(".rm-btn")) return;
      wdActive = true;
      wdStarted = false;
      wdPointerId = e.pointerId;
      wdStartX = e.screenX;
      wdStartY = e.screenY;
    });

    scene.addEventListener("pointermove", (e) => {
      if (!wdActive || wdStarted || e.pointerId !== wdPointerId) return;
      const dist = Math.hypot(e.screenX - wdStartX, e.screenY - wdStartY);
      if (dist > 3) {
        wdStarted = true;
        // Explicitly capture pointer â€” guarantees pointerup fires on scene
        try { scene.setPointerCapture(e.pointerId); } catch (_) {}
        // Cancel petting so dragging and petting don't conflict
        clearTimeout(longPressTimer);
        if (pettingInterval) { clearInterval(pettingInterval); pettingInterval = null; }
        isLongPress = false;
        document.getElementById("pettingBlush").classList.remove("visible");
        ipcRenderer.send("drag-window-start");
      }
    });

    scene.addEventListener("pointerup", (e) => {
      if (e.pointerId === wdPointerId) stopWindowDrag();
    });
    scene.addEventListener("pointercancel", (e) => {
      if (e.pointerId === wdPointerId) stopWindowDrag();
    });

    // â”€â”€ RADIAL CONTEXT MENU â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Right-click on pet â†’ circular action wheel appears around her

    const RADIAL_ACTIONS = [
      { icon: "ðŸ“", label: "Koko",     key: "size"               },  // top
      { icon: "ðŸŽ­", label: "Vibes!",   key: "vibes"              },  // top-right
      { icon: "âœ•",  label: "Sulje",    key: "close", closeBtn: true },  // bottom-right
      { icon: "ðŸ”Š", label: "Ã„Ã¤net",    key: "sound"              },  // bottom-left
      { icon: `<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg" style="width:22px;height:22px;display:block"><circle cx="16" cy="16" r="16" fill="#25d366"/><path fill="white" d="M16 7.5C11.3 7.5 7.5 11.3 7.5 16c0 1.5.4 2.9 1.1 4.2L7.5 24.5l4.4-1.1c1.2.6 2.6 1 4.1 1 4.7 0 8.5-3.8 8.5-8.5S20.7 7.5 16 7.5zm3.8 12c-.2.5-.9.9-1.5 1-.4 0-.9.1-2.8-.6-2.4-.9-3.9-3.3-4-3.4-.1-.2-1-1.3-1-2.5s.6-1.7.8-1.9c.2-.2.5-.3.6-.3h.4c.1 0 .4 0 .5.3l.6 1.5v.3l-.1.2-.2.3-.3.3c-.1.1-.2.2-.1.4.1.2.5.9 1.1 1.5.7.7 1.4 1 1.6 1 .2.1.3.1.4 0 .1-.1.5-.6.6-.8.2-.2.3-.2.5-.1.2.1 1.2.6 1.4.7.2.1.3.2.4.3.1.1.1.6-.1 1.2z"/></svg>`, label: "WhatsApp", key: "whatsapp", whatsapp: true },  // left
    ];

    // Expressions cycled by Vibes! button
    const VIBES_EXPRS = [
      { expr: "vibe",                msg: "Chillataan~ âœŒï¸",      icon: "ðŸ˜Ž" },
      { expr: "lovestruck_heart_eyes", msg: "Rakkautta! ðŸ’–",       icon: "ðŸ˜" },
      { expr: "laughing",            msg: "Hihihi! ðŸ˜‚",           icon: "ðŸ˜‚" },
      { expr: "winking_blep",        msg: "Peppi-mode! ðŸ˜œ",       icon: "ðŸ˜œ" },
      { expr: "hopeful_star_eyes",   msg: "TÃ¤htiin! â­",          icon: "â­" },
      { expr: "kissing",             msg: "Pusu! ðŸ’‹",             icon: "ðŸ’‹" },
      { expr: "smug",                msg: "KyllÃ¤ mÃ¤ tiesin ðŸ˜",   icon: "ðŸ˜" },
      { expr: "shy",                 msg: "Ujostutti... ðŸ˜³",      icon: "ðŸ˜³" },
      { expr: "thinking",            msg: "MietityttÃ¤Ã¤... ðŸ¤”",    icon: "ðŸ¤”" },
      { expr: "meditating",          msg: "ZenissÃ¤ ðŸ§˜",           icon: "ðŸ§˜" },
      { expr: "surprised",           msg: "YllÃ¤tys! ðŸ˜²",          icon: "ðŸ˜²" },
    ];
    let currentVibeIdx = 0;
    const SIZE_STEPS  = [0.75, 1.0, 1.3];
    const SIZE_LABELS = ["Pikkuinen! ðŸ¥ºðŸ’•", "Juuri sopiva! ðŸ’•", "Iso ja ihana! ðŸŒŸ"];
    let currentSizeStep = 1;
    let radialMenuOpen = false;
    // vibeActive declared early at top of script (line ~2679)

    const radialMenu   = document.getElementById("radialMenu");
    const radialRing   = document.getElementById("radialRing");
    const rmCenterBadge = document.getElementById("rmCenterBadge");

    // Creature visual center in scene coordinates
    // RM_CY=180 ensures bottom buttons (yâ‰ˆ180+81=261+23=284) fit inside 300px window
    const RM_CX = 130;
    const RM_CY = 180;
    const RM_RADIUS = 100;

    // Position the glow ring
    const ringSize = RM_RADIUS * 2 + 60;
    radialRing.style.width  = ringSize + "px";
    radialRing.style.height = ringSize + "px";
    radialRing.style.left   = RM_CX + "px";
    radialRing.style.top    = RM_CY + "px";

    // Create buttons dynamically
    RADIAL_ACTIONS.forEach((action, i) => {
      const angleDeg = -90 + (360 / RADIAL_ACTIONS.length) * i;
      const angleRad = angleDeg * Math.PI / 180;
      const bx = RM_CX + Math.round(RM_RADIUS * Math.cos(angleRad));
      const by = RM_CY + Math.round(RM_RADIUS * Math.sin(angleRad));

      const btn = document.createElement("div");
      btn.className = "rm-btn";
      btn.dataset.action = action.key;
      btn.style.left = bx + "px";
      btn.style.top  = by + "px";
      btn.style.transitionDelay = (i * 35) + "ms";
      if (action.whatsapp) {
        btn.innerHTML = action.icon; // SVG
      } else {
        btn.textContent = action.icon;
      }
      if (action.whatsapp) {
        btn.style.background = "linear-gradient(145deg, #075e54, #128c7e)";
        btn.style.borderColor = "rgba(37, 211, 102, 0.6)";
        btn.style.boxShadow = "0 4px 18px rgba(37, 211, 102, 0.4), inset 0 1px 0 rgba(255,255,255,0.12)";
      }
      if (action.closeBtn) {
        btn.style.background = "linear-gradient(145deg, #7b1a1a, #c0392b)";
        btn.style.borderColor = "rgba(255, 100, 100, 0.6)";
        btn.style.boxShadow = "0 4px 18px rgba(220, 50, 50, 0.4), inset 0 1px 0 rgba(255,255,255,0.12)";
        btn.style.fontSize = "16px";
        btn.style.fontWeight = "700";
      }

      // Show label in center badge on hover â€” only when menu is actually open
      btn.addEventListener("mouseenter", () => {
        if (!radialMenuOpen) return;
        rmCenterBadge.textContent = action.label;
        rmCenterBadge.classList.add("visible");
      });
      btn.addEventListener("mouseleave", () => {
        rmCenterBadge.classList.remove("visible");
      });

      btn.addEventListener("click", (e) => {
        e.stopPropagation();
        if (action.key !== "vibes") closeRadialMenu();
        handleRadialAction(action.key);
      });

      radialMenu.appendChild(btn);
    });

    function openRadialMenu() {
      radialMenuOpen = true;
      // Re-apply stagger delays for fan-in
      radialMenu.querySelectorAll(".rm-btn").forEach((b, i) => {
        b.style.transitionDelay = (i * 35) + "ms";
      });
      radialMenu.classList.add("visible");
      updateSpriteSkin("hopeful_star_eyes");
      // Brief sparkle to signal it's interactive
      spawnSparkleBurst(RM_CX, RM_CY - 40, 2);
    }

    function closeRadialMenu() {
      radialMenuOpen = false;
      vibeActive = false;
      // Reset delays so next open fans out cleanly
      radialMenu.querySelectorAll(".rm-btn").forEach((b, i) => {
        b.style.transitionDelay = (i * 35) + "ms";
      });
      radialMenu.classList.remove("visible");
      // Remove delays after animation completes
      setTimeout(() => {
        radialMenu.querySelectorAll(".rm-btn").forEach(b => { b.style.transitionDelay = "0ms"; });
      }, 300);
      rmCenterBadge.classList.remove("visible");
      // Restore expression after short delay
      setTimeout(() => {
        if (!isLongPress) {
          const expr = EXPRESSION_MAP[currentState] || "happy";
          updateSpriteSkin(expr);
        }
      }, 120);
    }

    // Open on right-click
    creature.addEventListener("contextmenu", (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (radialMenuOpen) {
        closeRadialMenu();
      } else {
        openRadialMenu();
      }
    });

    // Close on any click outside buttons
    document.addEventListener("click", (e) => {
      if (radialMenuOpen && !e.target.classList.contains("rm-btn")) {
        closeRadialMenu();
      }
    });
    document.addEventListener("contextmenu", (e) => {
      if (radialMenuOpen && !e.target.classList.contains("rm-btn")) {
        e.preventDefault();
        closeRadialMenu();
      }
    });
    // Close when window loses focus (user clicks VS Code, desktop, etc.)
    window.addEventListener("blur", () => {
      if (radialMenuOpen) closeRadialMenu();
    });

    // â”€â”€ ACTION HANDLERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function handleRadialAction(key) {
      switch (key) {

        case "size": {
          currentSizeStep = (currentSizeStep + 1) % SIZE_STEPS.length;
          const scale = SIZE_STEPS[currentSizeStep];
          creature.style.transform = `translateX(-50%) scale(${scale})`;
          creature.style.transition = "transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1)";
          showLocalMessage(SIZE_LABELS[currentSizeStep], "ðŸ“", 3000, true);
          spawnSparkleBurst(RM_CX, RM_CY - 30, 3);
          updateSpriteSkin("surprised");
          setTimeout(() => updateSpriteSkin(EXPRESSION_MAP[currentState] || "happy"), 1800);
          break;
        }

        case "vibes": {
          vibeActive = true;
          const vibe = VIBES_EXPRS[currentVibeIdx % VIBES_EXPRS.length];
          currentVibeIdx++;
          updateSpriteSkin(vibe.expr);
          showLocalMessage(vibe.msg, vibe.icon, 3500, true);
          spawnSparkleBurst(RM_CX, RM_CY - 30, 3);
          // Show vibe name in badge â€” menu stays open so user can cycle through vibes
          rmCenterBadge.textContent = `${vibe.icon} ${vibe.msg}`;
          rmCenterBadge.classList.add("visible");
          break;
        }

        case "sound": {
          soundEnabled = !soundEnabled;
          if (petSounds) petSounds.volume(soundEnabled ? soundVolume : 0);
          const sndMsg = soundEnabled ? "Ã„Ã¤net pÃ¤Ã¤llÃ¤! ðŸ”ŠðŸ’•" : "Hiljaisena... ðŸ”‡";
          showLocalMessage(sndMsg, soundEnabled ? "ðŸ”Š" : "ðŸ”‡", 3000, true);
          updateSpriteSkin(soundEnabled ? "happy" : "confused");
          setTimeout(() => updateSpriteSkin(EXPRESSION_MAP[currentState] || "happy"), 1800);
          break;
        }

        case "whatsapp": {
          shell.openExternal("whatsapp://");
          updateSpriteSkin("hopeful_star_eyes");
          showLocalMessage("Avataan WhatsApp! ðŸ’¬ðŸ’•", "ðŸ“±", 3000, true);
          spawnSparkleBurst(RM_CX, RM_CY - 30, 3);
          setTimeout(() => updateSpriteSkin(EXPRESSION_MAP[currentState] || "happy"), 2500);
          break;
        }

        case "sleep": {
          setState("idle-sleepy");
          spawnZzz(3);
          showLocalMessage("Zzz... lepÃ¤Ã¤nkin hetken ðŸ’¤", "ðŸ˜´", 5000, true);
          break;
        }

        case "close": {
          ipcRenderer.send("app-close");
          break;
        }
      }
    }

  </script>
</body>
</html>
